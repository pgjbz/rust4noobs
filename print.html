<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introdução</a></li><li class="chapter-item expanded "><a href="basic/index.html"><strong aria-hidden="true">2.</strong> Básico</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="basic/01-about.html"><strong aria-hidden="true">2.1.</strong> Sobre a linguagem</a></li><li class="chapter-item expanded "><a href="basic/02-environment.html"><strong aria-hidden="true">2.2.</strong> Ambiente</a></li><li class="chapter-item expanded "><a href="basic/03-hello-world.html"><strong aria-hidden="true">2.3.</strong> Hello World</a></li><li class="chapter-item expanded "><a href="basic/04-data-types.html"><strong aria-hidden="true">2.4.</strong> Tipos de dados</a></li><li class="chapter-item expanded "><a href="basic/05-operators.html"><strong aria-hidden="true">2.5.</strong> Operadores</a></li><li class="chapter-item expanded "><a href="basic/06-conditions.html"><strong aria-hidden="true">2.6.</strong> Condicionais</a></li><li class="chapter-item expanded "><a href="basic/07-loops.html"><strong aria-hidden="true">2.7.</strong> Loops</a></li><li class="chapter-item expanded "><a href="basic/08-functions.html"><strong aria-hidden="true">2.8.</strong> Funções</a></li><li class="chapter-item expanded "><a href="basic/09-arrays.html"><strong aria-hidden="true">2.9.</strong> Arrays</a></li><li class="chapter-item expanded "><a href="basic/10-exercises.html"><strong aria-hidden="true">2.10.</strong> Exercícios</a></li></ol></li><li class="chapter-item expanded "><a href="intermediary-01/index.html"><strong aria-hidden="true">3.</strong> Intermediário 1</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="intermediary-01/01-strings.html"><strong aria-hidden="true">3.1.</strong> Strings</a></li><li class="chapter-item expanded "><a href="intermediary-01/02-pointers-intro.html"><strong aria-hidden="true">3.2.</strong> Introdução a ponteiros</a></li><li class="chapter-item expanded "><a href="intermediary-01/03-ownership.html"><strong aria-hidden="true">3.3.</strong> Ownership</a></li><li class="chapter-item expanded "><a href="intermediary-01/04-tuples.html"><strong aria-hidden="true">3.4.</strong> Tuplas</a></li><li class="chapter-item expanded "><a href="intermediary-01/05-slices.html"><strong aria-hidden="true">3.5.</strong> Slices</a></li><li class="chapter-item expanded "><a href="intermediary-01/06-user-input.html"><strong aria-hidden="true">3.6.</strong> Entrada de dados</a></li><li class="chapter-item expanded "><a href="intermediary-01/07-exercises.html"><strong aria-hidden="true">3.7.</strong> Exercícios</a></li></ol></li><li class="chapter-item expanded "><a href="intermediary-02/index.html"><strong aria-hidden="true">4.</strong> Intermediário 2</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="intermediary-02/01-structs.html"><strong aria-hidden="true">4.1.</strong> Struct</a></li><li class="chapter-item expanded "><a href="intermediary-02/02-enums.html"><strong aria-hidden="true">4.2.</strong> Enum</a></li><li class="chapter-item expanded "><a href="intermediary-02/03-match.html"><strong aria-hidden="true">4.3.</strong> Match</a></li><li class="chapter-item expanded "><a href="intermediary-02/04-modules.html"><strong aria-hidden="true">4.4.</strong> Módulos</a></li><li class="chapter-item expanded "><a href="intermediary-02/05-generics.html"><strong aria-hidden="true">4.5.</strong> Generics</a></li><li class="chapter-item expanded "><a href="intermediary-02/06-traits.html"><strong aria-hidden="true">4.6.</strong> Traits</a></li><li class="chapter-item expanded "><a href="intermediary-02/07-option.html"><strong aria-hidden="true">4.7.</strong> Enum especial Option</a></li><li class="chapter-item expanded "><a href="intermediary-02/08-vec.html"><strong aria-hidden="true">4.8.</strong> Coleções: Vec</a></li><li class="chapter-item expanded "><a href="intermediary-02/09-hashset.html"><strong aria-hidden="true">4.9.</strong> Coleções: HashSet</a></li><li class="chapter-item expanded "><a href="intermediary-02/10-hashmap.html"><strong aria-hidden="true">4.10.</strong> Coleções: HashMap</a></li><li class="chapter-item expanded "><a href="intermediary-02/11-result.html"><strong aria-hidden="true">4.11.</strong> Tratamento de erros</a></li><li class="chapter-item expanded "><a href="intermediary-02/12-panic.html"><strong aria-hidden="true">4.12.</strong> Macro panic!</a></li><li class="chapter-item expanded "><a href="intermediary-02/13-tests.html"><strong aria-hidden="true">4.13.</strong> Testes</a></li><li class="chapter-item expanded "><a href="intermediary-02/14-snake.html"><strong aria-hidden="true">4.14.</strong> Mini projeto * Snake Game</a></li></ol></li><li class="chapter-item expanded "><a href="advanced-01/index.html"><strong aria-hidden="true">5.</strong> Avançado 1</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="advanced-01/01-lifetimes.html"><strong aria-hidden="true">5.1.</strong> Lifetimes</a></li><li class="chapter-item expanded "><a href="advanced-01/02-smart-pointers.html"><strong aria-hidden="true">5.2.</strong> Smart Pointers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="advanced-01/02-smart-pointers-box.html"><strong aria-hidden="true">5.2.1.</strong> Box&lt;T&gt;</a></li><li class="chapter-item expanded "><a href="advanced-01/02-smart-pointers-rc.html"><strong aria-hidden="true">5.2.2.</strong> Rc&lt;T&gt;</a></li><li class="chapter-item expanded "><a href="advanced-01/02-smart-pointers-refcell.html"><strong aria-hidden="true">5.2.3.</strong> RefCell&lt;T&gt;</a></li></ol></li><li class="chapter-item expanded "><a href="advanced-01/03-closures.html"><strong aria-hidden="true">5.3.</strong> Closures</a></li><li class="chapter-item expanded "><a href="advanced-01/04-threads.html"><strong aria-hidden="true">5.4.</strong> Threads</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="advanced-01/04-threads-arc-mutex-rwlock.html"><strong aria-hidden="true">5.4.1.</strong> Arc&lt;T&gt;, Mutex&lt;T&gt; e RwLock&lt;T&gt;</a></li></ol></li><li class="chapter-item expanded "><a href="advanced-01/05-producers-consumers.html"><strong aria-hidden="true">5.5.</strong> Produtores e Consumidores</a></li></ol></li><li class="chapter-item expanded "><a href="extras/index.html"><strong aria-hidden="true">6.</strong> Extras</a></li><li class="chapter-item expanded "><a href="SOURCES.html"><strong aria-hidden="true">7.</strong> Referências</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- Logo 4noobs -->
<p align="center">
  <a href="https://github.com/he4rt/4noobs" target="_blank">
    <img src="./assets/header_4noobs.svg">
  </a>
</p>
<!-- Title -->
<p align="center">
  <h2 align="center">Rust4Noobs</h2>
<h1 align="center"><img src="./assets/rust.svg" alt="Imagem da linguagem" width="420"></h1>
</p>
<h2 id="sobre-o-projeto"><a class="header" href="#sobre-o-projeto">Sobre o Projeto</a></h2>
<p>Projeto para introdução a linguagem de programação Rust, o objetivo deste livro é inserir o leitor aos conceitos da linguagem Rust, como o seu modo de gerenciamento de memória e conceitos da linguagem.</p>
<h2 id="autores"><a class="header" href="#autores">Autores</a></h2>
<ul>
<li>Paulo Gabriel Justino Bezerra - Desenvolvedor Java - <a href="https://www.linkedin.com/in/paulogjbezerra/">Linkedin</a></li>
</ul>
<hr />
<h2 id="pessoas-que-melhoraram-este-projeto"><a class="header" href="#pessoas-que-melhoraram-este-projeto">Pessoas que melhoraram este projeto</a></h2>
<!-- readme: collaborators,contributors -start -->
<!-- readme: collaborators,contributors -end -->
<p align="center">
  <a href="https://github.com/he4rt/4noobs" target="_blank">
    <img src="./assets/footer_4noobs.svg" width="380">
  </a>
</p><div style="break-before: page; page-break-before: always;"></div><h1 id="básico"><a class="header" href="#básico">Básico</a></h1>
<p>Este é o início da nossa caminhada de aprendizado da linguagem de programação Rust, nesta seção você encontrara coisas como configurações de ambiente, tipos, estrutura de decisão, loops e funções.</p>
<p>Roadmap:</p>
<ul>
<li><a href="basic/./01-about.html">Sobre a linguagem</a></li>
<li><a href="basic/./02-environment.html">Ambiente</a></li>
<li><a href="basic/./03-hello-world.html">Hello World</a></li>
<li><a href="basic/./04-data-types.html">Tipos de dados</a></li>
<li><a href="basic/./05-operators.html">Operadores</a></li>
<li><a href="basic/./06-conditions.html">Condicionais</a></li>
<li><a href="basic/./07-loops.html">Loops</a></li>
<li><a href="basic/./08-functions.html">Funções</a></li>
<li><a href="basic/./09-arrays.html">Arrays</a></li>
<li><a href="basic/./10-exercises.html">Exercícios</a></li>
</ul>
<hr><div style="break-before: page; page-break-before: always;"></div><h1 id="breve-resumo-sobre-a-linguagem-rust"><a class="header" href="#breve-resumo-sobre-a-linguagem-rust">Breve resumo sobre a linguagem Rust</a></h1>
<p><a href="https://www.rust-lang.org/pt-BR">Rust</a> é uma linguagem de programação de código aberto, desenvolvida pela Mozilla, seu desenvolvimento iniciou em meados de 2006. No ano de 2010 foi anunciado o Rust 1.0, de lá para cá já aconteceram diversas melhorias e mudanças na linguagem, sua última versão no momento em que este repositório começou a ser escrito é a versão <a href="https://github.com/rust-lang/rust/releases/tag/1.56.1">1.56.1 - Stable</a>.</p>
<p>Rust é rápido, compilado, gerencia a memória de maneira muito eficiente, sem Garbage Collector, sem runtime, é rico em conteúdo e tem uma comunidade gigantesca.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ambiente"><a class="header" href="#ambiente">Ambiente</a></h1>
<h2 id="instalação-do-rust"><a class="header" href="#instalação-do-rust">Instalação do Rust</a></h2>
<h3 id="linux"><a class="header" href="#linux">Linux</a></h3>
<p>As distribuições Linux testadas para a instalação de Rust foram:</p>
<ul>
<li>Arch Linux</li>
<li>Fedora</li>
<li>Ubuntu</li>
</ul>
<p>Para realizar a instalação da linguagem é necessário ter a ferramenta <a href="https://curl.se/">curl</a> instalada no sistema, para a instalação do <code>curl</code> nas distribuições testadas foram utilizados os seguintes métodos:</p>
<p>Arch Linux:</p>
<pre><code class="language-bash">sudo pacman -S curl
</code></pre>
<p>Fedora:</p>
<pre><code class="language-bash">sudo dnf install curl
</code></pre>
<p>Ubuntu:</p>
<pre><code class="language-bash">sudo apt install curl
</code></pre>
<p>Com a ferramenta <code>curl</code> instalada foi utilizado o método de instalação <a href="https://www.rust-lang.org/pt-BR/learn/get-started">recomendado</a> no site da linguagem:</p>
<pre><code class="language-bash">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<p>Este comando ira baixar o instalador do Rust e executa-lo no shell, para seguir escolha a opção 1 aperte enter. A instalação seria realizada.</p>
<h3 id="windows"><a class="header" href="#windows">Windows</a></h3>
<p>OBS. Método de instalação utilizando o gerenciador de pacotes do Windows oficial da Microsoft <a href="https://winget.run/">winget</a>.</p>
<p>Para instalar o Rust no Windows execute o seguinte comando em um PowerShell como administrador:</p>
<pre><code class="language-bash">winget install -e --id Rustlang.rust-gnu-x64
</code></pre>
<h3 id="validando-instalação"><a class="header" href="#validando-instalação">Validando instalação</a></h3>
<p>Para validarmos a instalação utilizamos o comando:</p>
<pre><code class="language-bash">cargo --version
</code></pre>
<p>Ele deve nos mostrar algo parecido com isso:</p>
<pre><code class="language-bash">cargo 1.56.0 (4ed5d137b 2021-10-04)
</code></pre>
<p>E logo em sequência o comando</p>
<pre><code class="language-bash">rustc --version
</code></pre>
<p>O comando deve nos retornar algo parecido com isso:</p>
<pre><code class="language-bash">rustc 1.56.0 (09c42c458 2021-10-18)
</code></pre>
<h1 id="ides"><a class="header" href="#ides">IDEs</a></h1>
<p>Temos algumas <a href="https://pt.wikipedia.org/wiki/Ambiente_de_desenvolvimento_integrado">IDE</a>'s que podem facilitar a nossa vida no desenvolvimento utilizando Rust</p>
<ul>
<li><a href="https://www.jetbrains.com/pt-br/idea/download/">IntelliJ</a> com o Plugin para Rust</li>
<li><a href="https://code.visualstudio.com/">VSCode</a> com os seguintes plugins:
<ul>
<li><a href="https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb">CodeLLDB</a> para debug</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=matklad.rust-analyzer">rust-analyzer</a> language server é util para lermos a documentação e termos o intellisense enquanto escrevemos códigos</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=serayuzgur.crates">crates</a> para nos ajudar no gerenciamento de dependência do projeto</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nosso-primeiro-hello-world"><a class="header" href="#nosso-primeiro-hello-world">Nosso primeiro &quot;Hello World&quot;</a></h1>
<p>Após a instalação de um compilador nada melhor que iniciarmos com o famoso &quot;Hello World!&quot;, a instalação da linguagem nos fornece a ferramenta <code>cargo</code> com esta ferramenta conseguimos criar  projetos em Rust, gerenciar dependências, rodar testes, rodar a aplicação e dar build na aplicação.</p>
<p>Para criarmos nosso primeiro projeto, iremos utilizar o seguinte comando:</p>
<pre><code class="language-bash">cargo new hello-rust
</code></pre>
<p>Este comando ira criar um projeto com a seguinte estrutura:</p>
<pre><code class="language-bash">├── Cargo.toml
└── src
    └── main.rs
</code></pre>
<p>O arquivo <code>Cargo.toml</code> é o arquivo onde temos as informações sobre o projeto, como nome, versão, autor(es), dependências, opções de build, edição, etc.</p>
<p>Na pasta <code>src</code> temos o código-fonte do nosso projeto, neste caso o como o nosso projeto é de um executável temos o arquivo <code>main.rs</code>,  nele esta o início de nossa jornada em códigos Rust.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>Temos a palavra reservada <code>fn</code> que é palavra que define uma função, temos o <a href="https://doc.rust-lang.org/book/ch19-06-macros.html">macro</a> <code>println!</code> que é o responsável por escrever no nosso console.</p>
<p>Executando o comando</p>
<pre><code class="language-bash">cargo run
</code></pre>
<p>Teremos nosso primeiro código em Rust sendo executado e a mensagem <code>Hello, world!</code> sendo mostrada no nosso console. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tipos-de-dados"><a class="header" href="#tipos-de-dados">Tipos de dados</a></h1>
<p>Rust é uma linguagem fortemente e estaticamente tipada, nela temos alguns tipos</p>
<h3 id="tipos"><a class="header" href="#tipos">Tipos</a></h3>
<table><thead><tr><th>Tipo</th><th>Tamanho</th><th>Valor Máximo</th><th>Valor Mínimo</th><th></th></tr></thead><tbody>
<tr><td>i8</td><td>1 byte</td><td>127</td><td>-128</td><td>Numérico</td></tr>
<tr><td>u8</td><td>1 byte</td><td>255</td><td>0</td><td>Numérico</td></tr>
<tr><td>i16</td><td>2 bytes</td><td>32767</td><td>-32768</td><td>Numérico</td></tr>
<tr><td>u16</td><td>2 bytes</td><td>65535</td><td>0</td><td>Numérico</td></tr>
<tr><td>i32</td><td>4 bytes</td><td>2147483647</td><td>-2147483648</td><td>Numérico</td></tr>
<tr><td>u32</td><td>4 bytes</td><td>4294967295</td><td>0</td><td>Numérico</td></tr>
<tr><td>i64</td><td>8 bytes</td><td>9223372036854775807</td><td>-9223372036854775808</td><td>Numérico</td></tr>
<tr><td>u64</td><td>8 bytes</td><td>18446744073709551615</td><td>0</td><td>Numérico</td></tr>
<tr><td>i128</td><td>16 bytes</td><td>170141183460469231731687303715884105727</td><td>-170141183460469231731687303715884105728</td><td>Numérico</td></tr>
<tr><td>u128</td><td>16 bytes</td><td>340282366920938463463374607431768211455</td><td>0</td><td>Numérico</td></tr>
<tr><td>f32</td><td>4 bytes</td><td>340282350...</td><td>-340282350...</td><td>Numérico</td></tr>
<tr><td>f64</td><td>8 bytes</td><td>1797693134862315700...</td><td>-1797693134862315700...</td><td>Numérico</td></tr>
<tr><td>bool</td><td>1 byte</td><td>true</td><td>false</td><td>booleano</td></tr>
<tr><td>char</td><td>4 bytes</td><td>'\0'</td><td>􏿿</td><td>character</td></tr>
</tbody></table>
<p>Temos também o tipo <code>usize</code> que vai dependender da arquitetura do sistema operacional.</p>
<h3 id="variáveis"><a class="header" href="#variáveis">Variáveis</a></h3>
<p>Para declararmos &quot;variáveis&quot; em Rust utilizamos a palavra reservada <code>let</code>, mas o uso de apenas essa palavra para a declaração das &quot;variáveis&quot; armazena tipos imutáveis, para termos variáveis que podem ser alteradas temos que utilizar outra palavra reservada <code>mut</code>.</p>
<p>Temos dois modos de declarar variáveis, uma em que falamos o tipo para o compilador e outra que o compilador &quot;decide o tipo&quot; para nós. Para a declaração que informamos o tipo temos a seguinte sintaxe <code>let nome: tipo = valor</code> e para a que o compilador decide temos a sintaxe <code>let nome = valor</code>;</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let idade_atual: u8 = 22;
    let ano_nascimento = 1999; //inferencia de tipo

    println!(&quot;Idade atual {}, ano de nascimento: {}&quot;, idade_atual, ano_nascimento);
}
</code></pre></pre>
<p>No exemplo acima utilizamos a declaração do tipo e inferência do mesmo, mas também podemos dar uma dica ao compilador ao tipo que iremos utilizar, o tipo padrão para números inteiros é <code>i32</code>, mas é um disperdicio de alguns bytes, podemos fazer da seguinte maneira.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let idade_atual: u8 = 22;
    let ano_nascimento = 1999_u16;

    println!(&quot;Idade atual {}, ano de nascimento: {}&quot;, idade_atual, ano_nascimento);
}
</code></pre></pre>
<p>Deste modo temos outro jeito de informar ao compilador que tipos queremos utilizar, porém, para este exemplo não faz muito sentido.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let crab_power = 100_f32;

    println!(&quot;Poder do carangueijo {}%&quot;, crab_power);
}
</code></pre></pre>
<p>Mas para casos como este, esse tipo de abordagem faz mais sentido.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operadores"><a class="header" href="#operadores">Operadores</a></h1>
<p>Antes de entrarmos nas estruturas condicionais, precisamos saber os operadores.</p>
<h2 id="operadores-matemáticos"><a class="header" href="#operadores-matemáticos">Operadores matemáticos</a></h2>
<table><thead><tr><th>Tipo</th><th>Simbolo</th><th>Ação</th></tr></thead><tbody>
<tr><td>Soma</td><td>+</td><td>Soma dois valores</td></tr>
<tr><td>Subtração</td><td>-</td><td>Subtrai dois valores</td></tr>
<tr><td>Multiplicação</td><td>*</td><td>Multiplica dois valores</td></tr>
<tr><td>Divisão</td><td>/</td><td>Divide dois valores</td></tr>
<tr><td>Mod</td><td>%</td><td>Resto de divisão</td></tr>
<tr><td>Soma atribui</td><td>+=</td><td>Soma e atribui o valor</td></tr>
<tr><td>Subtrai e atribui</td><td>-=</td><td>Subtrai e atribui o valor</td></tr>
<tr><td>Multiplica e atribui</td><td>*=</td><td>Multiplica e atribui o valor</td></tr>
<tr><td>Divide e atribui</td><td>/=</td><td>Divide e atribui o valor</td></tr>
</tbody></table>
<p>No capítulo sobre os <a href="basic/./04-data-types.html">tipos de dados</a> mostramos como declarar variáveis e também sobre o caso do Rust precisar de uma palavra extra para essas variáveis serem modificadas, mas não a utilizamos, neste capítulo iremos utilizar, nos exemplos dos usos dos operadores matemáticos.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut n = 10 - 1; //n = 9
    n = 1 + 2; //n = 3
    n = 10 * 2; //n = 20
    n = 10 / 2; //n = 5
    /*
    Agora temos o valor de n = a 5, iremos realizar operações de atribuições com base neste valor.
    */
    n += 1; //n = 6
    n -= 2; //n = 4
    n *= 3; //n = 12
    n /= 4; //n = 3
}
</code></pre></pre>
<h2 id="operadores-lógicos"><a class="header" href="#operadores-lógicos">Operadores lógicos</a></h2>
<table><thead><tr><th>Tipo</th><th>Simbolo</th><th>Ação</th></tr></thead><tbody>
<tr><td>Igual</td><td>==</td><td>Compara se dois valores são iguais</td></tr>
<tr><td>Diferente</td><td>!=</td><td>Verifica se dois valores são diferentes</td></tr>
<tr><td>Maior</td><td>&gt;</td><td>Verifica se um valor é maior que outro</td></tr>
<tr><td>Menor</td><td>&lt;</td><td>Verifica se um valor é menor que outro</td></tr>
<tr><td>Maior igual</td><td>&gt;=</td><td>Verifica se um valor é maior ou igual a outro</td></tr>
<tr><td>Maior igual</td><td>&lt;=</td><td>Verifica se um valor é menor ou igual a outro</td></tr>
</tbody></table>
<p>O uso dos operadores lógicos iremos ver na <a href="basic/./06-conditions.html">próxima</a> parte</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="condições"><a class="header" href="#condições">Condições</a></h1>
<p>Em Rust como em todas as linguagens de programação, ou pelo menos a maioria, temos estruturas de decisões, são bem parecidas, com base em uma condição tomamos uma decisão.</p>
<p>Para utilizar estruturas condicionais em Rust devemos utilizar a palavra reservada <code>if</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = 20;
    let b = 10;
    
    if a &gt; b {
        println!(&quot;'a' é maior que 'b'&quot;);
    }
}
</code></pre></pre>
<p>E se quisermos executar algo caso a condição não seja verdadeira?? Utilizamos a palavra <code>else</code></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = 10;
    let b = 20;
    
    if a &gt; b {
        println!(&quot;'a' é maior que 'b'&quot;);
    } else {
        println!(&quot;'b' é maior que 'a'&quot;);
    }
}
</code></pre></pre>
<p>Simples né? E se quisermos realizar outra checagem caso a primeira condição não de verdadeira? Simples combinamos o <code>else</code> e o <code>if</code></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = 10;
    let b = 20;
    let c = 15;
    
    if a &gt; b {
        println!(&quot;'a' é maior que 'b'&quot;);
    } else if b &gt; c {
        println!(&quot;'b' é maior que 'a'&quot;);
    } else { //caso não aconteça nenhum dos casos cai aqui
        println!(&quot;'c' é maior que 'b'&quot;);
    }
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="loops"><a class="header" href="#loops">Loops</a></h1>
<p>Caso queiramos repetir alguma instrução, várias e várias vezes, o que fazemos? Escrevemos o mesmo código inúmeras vezes? Claro que não, para fazermos isso utilizamos loops.</p>
<p>Em Rust temos 3 tipos de loops <code>for</code>, <code>while</code> e <code>loop</code>, todos de fácil utilização, todos com suas peculiaridades, mas no fim utilizamos para a mesma coisa, repetir coisas. </p>
<h2 id="loop-for"><a class="header" href="#loop-for">Loop FOR</a></h2>
<p>O loop <code>for</code>, provavelmente é o mais utilizado, não necessariamente do modo que iremos aprender agora, mas isso vem depois, agora iremos focar no básico de sua utilização.</p>
<p>Sua declaração é feita da seguinte maneira <code>for variavel in de..até</code></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    for i in 0..10 {
        println!(&quot;{}&quot;, i);
    }
}
</code></pre></pre>
<p>Agora temos um loop for que vai de 0 até 9, pode não ser muito intuitivo logo de início, lendo o código parece que iria ir de 0 até 10, todavia sempre sera <code>valor até - 1</code></p>
<h2 id="loop-while"><a class="header" href="#loop-while">Loop WHILE</a></h2>
<p>O loop <code>while</code> é uma estrutura de repetição que se repete por tempo indeterminado, diferente do loop <code>for</code> ela ira se repetir infinitamente enquanto a condição for verdadeira.</p>
<p>Sua declaração é <code>while condicao</code></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut i = 0;
    while i &lt;= 10 {
        println!(&quot;{}&quot;, i);
        i += 1;
    }
}
</code></pre></pre>
<p>Agora temos um loop <code>while</code>que ira repetir enquanto i for menor ou igual a 10, a partir do momento que esta condição não for satisfeita, o loop ira ser encerrado. </p>
<p>Em alguns momentos queremos loops infinitos, o que você faria? Utilizaria um <code>while true</code>? Não é necessário no Rust temos...</p>
<h2 id="loop-loop"><a class="header" href="#loop-loop">Loop &quot;loop&quot;</a></h2>
<p>Quando queremos ter um loop infinito podemos utilizar a palavra reservada loop, esta palavra cria um bloco que se repete infinitamente</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    loop {
        println!(&quot;Rust4Noobs&quot;);
    }
}
</code></pre></pre>
<p>Agora temos um bloco que irá escrever &quot;Rust4Noobs&quot; infinitamente.</p>
<h2 id="palavra-break"><a class="header" href="#palavra-break">Palavra break</a></h2>
<p>Nem sempre queremos que um loop execute completamente antes de encerrar, para isso temos a palavra <code>break</code> ela tem a função de parar uma estrutura de repetição. Serve tanto para blocos for, while e loop</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    for i in 1..100 {
        println!(&quot;{}&quot;, i);
        if i % 3 == 0 &amp;&amp; i % 9 == 0 {
            println!(&quot;Parou!&quot;);
            break;
        }
    }

    let mut i = 0;
    while i &lt;= 100 {
        println!(&quot;{}&quot;, i);
        if i == 10 {
            println!(&quot;Parou!&quot;);
            break;
        }
        i+= 1;

    }

    i = 0;

    loop {
        println!(&quot;{}&quot;, i);
        if i == 10 {
            println!(&quot;Parou!&quot;);
            break;
        }
        i+= 1;
    }
}
</code></pre></pre>
<h2 id="palavra-continue"><a class="header" href="#palavra-continue">Palavra continue</a></h2>
<p>Utilizamos a palavra <code>continue</code> quando queremos pular uma parte do loop, por exemplo. Temos um loop de 0 a 99 onde queremos escrever no console todos os números, exceto os múltiplos de 4 e 6 ao mesmo tempo. Podemos usar um continue para isso.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    for i in 0..100 {
        if i % 4 == 0 &amp;&amp; i % 6 == 0 {
            continue;
        }
        println!(&quot;Numero atual {}&quot;, i);
    }
}
</code></pre></pre>
<p>Claro isso não se aplica somente ao for, é possível utilizar com <code>while</code> e com <code>loop</code> também</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="funções"><a class="header" href="#funções">Funções</a></h1>
<p>Em Rust já vimos a função <code>main</code> a função responsável por ser o ponto de partida da nossa aplicação, porém não é muito legal realizarmos todas as operações dentro desta única função, porque além de causar a repetição de código ainda temos um grande problema, ela ficará <strong>GIGANTESCA</strong>, para resolver este problema podemos criar funções menores, que fazem pequenas coisas. </p>
<h2 id="funções-sem-argumento"><a class="header" href="#funções-sem-argumento">Funções sem argumento</a></h2>
<p>Temos funções com e sem argumentos, com e sem retorno, agora iremos falar das sem argumentos e com ou sem retorno.</p>
<p>A declaração de uma função em Rust é simples, utilizamos o seguinte padrão <code>fn nome()</code> ou <code>fn nome() -&gt; tipo retorno</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn quanto_e_um_mais_dois() -&gt; u8 {
    3
}

fn escreve_hello_world_dez_vezes() {
    for i in 0..10 {
        println!(&quot;Hello World!&quot;);
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="retorno-de-funções"><a class="header" href="#retorno-de-funções">Retorno de funções</a></h2>
<p>Temos dois modos de realizar o retorno de uma função em Rust, um deles é o retorno sendo a última linha do bloco da função sem a palavra <code>return</code> e sem o <code>;</code> o segundo modo é utilizarmos a palavra <code>return</code> propriamente dita.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn retorno_implicito() -&gt; bool {
    true
}

fn retorno_explicito() -&gt; u8 {
    if 10 &gt; 1 {
        return 200; //a palavra return encerra a função e retorna o valor
    }
    1 //retorno implicito na mesma função
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="funções-com-parâmetros"><a class="header" href="#funções-com-parâmetros">Funções com parâmetros</a></h2>
<p>Temos também podemos passar argumentos nas funções, para isso utilizamos o seguinte padrão de assinatura <code>fn nome_funcao(parametros com seus tipos)</code> ou <code>fn nome_funcao(parametros com seus tipos) -&gt; tipo retorno</code>.</p>
<p>Por exemplo, precisamos de um programa que faça o cálculo de impostos para uma nota fiscal e no fim deste cálculo nos exiba no console o valor destes impostos.</p>
<p>O modo mais ingenuo de fazer isso com o que aprendemos até agora seria da seguinte maneira:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let valor = 100.0;
    let icms = valor * 0.01;
    let iss = valor * 0.10;
    println!(&quot;Icms: {}&quot;, icms);
    println!(&quot;Iss: {}&quot;, iss);
}
</code></pre></pre>
<p>Porém, temos um problema aí, e se eu quiser calcular vários valores diferentes, eu iria repetir este o bloco do cálculo? Não, eu posso extrair este calculo para uma função, a mesma coisa para exibir no console. Ficando da seguinte maneira:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let valor = 100.0;
    let icms = calcula_icms(valor);
    let iss = calcula_iss(valor);
    escreve_icms(icms);
    escreve_iss(iss);
}

fn calcula_icms(valor: f32) -&gt; f32 {
    valor * 0.01
}

fn calcula_iss(valor: f32) -&gt; f32 {
    valor * 0.10
}

fn escreve_icms(icms: f32) {
    println!(&quot;Icms: {}&quot;, icms);
}

fn escreve_iss(iss: f32) { 
    println!(&quot;Iss: {}&quot;, iss);
}
</code></pre></pre>
<p>A primeira instância parece apenas que escrevemos mais, porém com os nomes expressivos conseguimos saber exatamente o que esta acontecendo e podemos chamar estes blocos de códigos de diversos lugares.</p>
<p>As funções são algo muito útil, mas em Rust temos que ter um certo cuidado com elas, mas este cuidado iremos ver na parte intermediaria deste 4Noobs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arrays"><a class="header" href="#arrays">Arrays</a></h1>
<h1 id="arrays-1"><a class="header" href="#arrays-1">Arrays</a></h1>
<p>Chegou o momento daquele assunto que é um dos terrores para quem esta começando a programar, os <a href="https://en.wikipedia.org/wiki/Array_data_structure">arrays</a>.</p>
<p>Array é uma estrutura de dados sequêncial que armazena o mesmo tipo de dados, seriam como uma sequência de células de memória indexadas. Geralmente iniciamos sua contagem a partir do número 0.</p>
<h1 align="center"><img src="basic/../assets/arrays.svg" alt="arrays" width="100%"></h1>
<p>Em Rust declaramos arrays da seguinte maneira <code>let nome: [tipo; tamanho] = [valor; tamanho]</code>, Rust nos obriga a inicializar o array, então faremos da seguinte maneira.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let array: [u8; 7] = [0; 7];
}
</code></pre></pre>
<p>Deste modo temos um array de 7 posições preenchido com o valor 0, para acessarmos valores específicos dentro do array utilizamos os colchetes <code>[posicao]</code>, para modificarmos qualquer valor dentro do array também precisamos do uso da palavra <code>mut</code>.</p>
<p>Em um array temos o método <code>len</code> onde conseguimos saber o tamanho do array, este método é muito util para realizar um <a href="basic/./07-loops.html">loop for</a> para percorrer o array.</p>
<p>Iremos realizar uma simples operação com um array, teremos um array de 10 posições e iremos percorrer esse array e daremos o valor para cada posição com a seguinte regra: posição + 10, e logo depois iremos imprimir no console este array.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut array: [u8; 10] = [0; 10];
    for i in 0..array.len() {
        array[i] = i as u8 + 10u8;
    }

    for i in 0..array.len() {
        println!(&quot;Pos: {}, val: {}&quot;, i, array[i]);
    }
}
</code></pre></pre>
<p>O uso da palavra <code>as</code> será discutido depois, após a execução do código acima temos o resultado:</p>
<pre><code class="language-bash">Pos: 0, val: 10
Pos: 1, val: 11
Pos: 2, val: 12
Pos: 3, val: 13
Pos: 4, val: 14
Pos: 5, val: 15
Pos: 6, val: 16
Pos: 7, val: 17
Pos: 8, val: 18
Pos: 9, val: 19
</code></pre>
<p>Também temos outro modo de executar este loop para realizar o print dos valores:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut array: [u8; 10] = [0; 10];
    for i in 0..array.len() {
        array[i] = i as u8 + 10u8;
    }

    for val in array {
        println!(&quot;Val: {}&quot;, val);
    }
}
</code></pre></pre>
<p>Do modo em que fizemos perdemos a informação do índice que estamos percorrendo, mas temos o seguinte resultado:</p>
<pre><code class="language-bash">Val: 10
Val: 11
Val: 12
Val: 13
Val: 14
Val: 15
Val: 16
Val: 17
Val: 18
Val: 19
</code></pre>
<p>Para termos o índice de volta podemos fazer da seguinte maneira:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut array: [u8; 10] = [0; 10];
    for i in 0..array.len() {
        array[i] = i as u8 + 10u8;
    }

    for (i, val) in array.iter().enumerate() {
        println!(&quot;pos: {}, val: {}&quot;, i, val);
    }
}
</code></pre></pre>
<p>Assim temos a saída:</p>
<pre><code class="language-bash">pos: 0, val: 10
pos: 1, val: 11
pos: 2, val: 12
pos: 3, val: 13
pos: 4, val: 14
pos: 5, val: 15
pos: 6, val: 16
pos: 7, val: 17
pos: 8, val: 18
pos: 9, val: 19
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercícios"><a class="header" href="#exercícios">Exercícios</a></h1>
<p>Nada melhor que exercícios para praticar o que aprendemos até agora, loops, arrays, operadores, tipos de dados e funções.</p>
<p>1 - Faça um programa que tenha uma função que recebe um array de inteiros com sinal (aceite números negativos) e devolva a soma dos valores deste array e exiba no console.</p>
<p>2 - Faça um programa que calcule a média entre quatro notas e informe se foi aprovado ou não e a média, para ser aprovado a média deve ser maior ou igual a 7.</p>
<p>3 - Faça um programa que percorra um vetor com valores inteiros e verifique quais múltiplos de 2.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="módulo-intermediário-1"><a class="header" href="#módulo-intermediário-1">Módulo intermediário 1</a></h1>
<p>Decidi dividir o módulo intermediário em dois, esta parte do módulo intermediário iremos falar sobre as strings, introdução aos ponteiros, sistema de ownership, tuplas, tipos <code>slice</code>, parse e casting.</p>
<p>Roadmap:</p>
<ul>
<li><a href="intermediary-01/./01-strings.html">Strings</a></li>
<li><a href="intermediary-01/./02-pointers-intro.html">Introdução a ponteiros</a></li>
<li><a href="intermediary-01/./03-ownership.html">Ownership</a></li>
<li><a href="intermediary-01/./04-tuples.html">Tuplas</a></li>
<li><a href="intermediary-01/./05-slices.html">Slices</a></li>
<li><a href="intermediary-01/./06-user-input.html">Entrada de dados</a></li>
<li><a href="intermediary-01/./07-exercises.html">Exercicios</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="strings"><a class="header" href="#strings">Strings</a></h1>
<p>Lembra dos <a href="intermediary-01/../basic/09-arrays.html">Arrays</a>? String são arrays, porém de um tipo específico <code>char</code>, existem varias formas de representar strings em Rust, nesta parte do 4Noobs, iremos utilizar um modo específico com o tipo <a href="https://doc.rust-lang.org/stable/std/string/struct.String.html">String</a>.</p>
<p>Para declararmos uma String utilizamos o seguinte padrão <code>let nome: String = String::from(texto entre aspas)</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() { 
    let texto = String::from(&quot;Hello World!&quot;); 
} 
</code></pre></pre>
<p>Acima temos a declaração da nossa String, nela temos alguns métodos, mas nesta parte iremos falar sobre os seguintes métodos len, push, push_str, trim.</p>
<p>Sendo os métodos <code>push</code> e <code>push_str</code> específicos para Strings mutáveis.</p>
<h2 id="string-len"><a class="header" href="#string-len">String len</a></h2>
<p>O método <code>len</code> nos retorna o tamanho da String, seu modo de uso é bem simples, apenas colocamos um <code>.len()</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let texto = String::from(&quot;Rust4Noobs&quot;);
    let tamanho_texto = texto.len();
    println!(&quot;O tamanho do texto é: {}&quot;, tamanho_texto);
}
</code></pre></pre>
<h2 id="string-push-e-push_str"><a class="header" href="#string-push-e-push_str">String push e push_str</a></h2>
<p>Com o método <code>push</code>, conseguimos adicionar um caractere a nossa <code>String</code> e com o <code>push_str</code> conseguimos adicionar outra String.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut texto = String::from(&quot;Rust&quot;);
    texto.push('4');
    texto.push_str(&quot;Noobs&quot;);
    println!(&quot;{}&quot;, texto);
}
</code></pre></pre>
<h2 id="string-trim"><a class="header" href="#string-trim">String trim</a></h2>
<p>O método <code>trim</code> remove os espaços do início e no fim de uma String, porém não modifica o texto original, ele nos retorna outra String sem estes espaços. O método é bem útil para quando formos realizar algum tipo conversão, mas iremos falar sobre isso posteriormente, por enquanto iremos focar apenas neste método.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let texto = String::from(&quot;   Rust4Noobs   &quot;);
    println!(&quot;Sem trim: {}
Com o uso de trim: {}&quot;, texto, texto.trim());
    println!(&quot;A string original se mantém: {}&quot;, texto);
}
</code></pre></pre>
<p>Não cobrimos alguns pontos importantes sobre este tipo de dado, por conta de alguns conceitos ainda não explicado, futuramente iremos retomar com as <code>Strings</code>. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introdução-a-ponteiros"><a class="header" href="#introdução-a-ponteiros">Introdução a Ponteiros</a></h1>
<p>Afinal, o que são <a href="https://en.wikipedia.org/wiki/Pointer_(computer_programming)">ponteiros</a>? Ponteiros seriam como váriaveis, porém elas armazenam outro tipo de informação, o endereço de memória de outro dado.</p>
<p>Fazendo uma analogia com o mundo real, a sua casa seria uma variável do tipo Casa, você consegue realizar ações e modifica-la como você deseja <del>desde que não, afete a integridade de sua moradia</del>, mas você tem um conhecido que também pode modificar sua casa, porém ele não mora nela e tem o seu endereço, ele sabe como chegar a sua casa para fazer esta modificação, este seria um ponteiro.</p>
<p>Ta não foi um bom exemplo, mas creio que fique mais fácil de entender com um desenho.</p>
<h1 align="center"><img src="intermediary-01/../assets/pointer.svg" alt="arrays" width="100%"></h1>
<p>Resumidamente os ponteiros simplismente dizem <del>&quot;olha eu sei onde você mora, fica esperto!&quot;</del> &quot;Eu conheço o endereço daquele cara ali&quot;.</p>
<h2 id="ponteiros-em-rust"><a class="header" href="#ponteiros-em-rust">Ponteiros em Rust</a></h2>
<p>Lembra que acabamos de ver as <a href="intermediary-01/./01-strings.html">strings</a>, o tipo String é de certa forma um ponteiro, ele aponta para um endereço de memória localizado no <a href="https://blog.pantuza.com/artigos/heap-vs-stack">heap</a>, é um &quot;tipo especial&quot; de ponteiro, mas agora iremos utilizar exemplos mais fáceis de manipular.</p>
<h3 id="referência-em-rust"><a class="header" href="#referência-em-rust">referência em Rust</a></h3>
<p>Para representarmos ponteiros em Rust utilizamos o caractere <code>&amp;</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a: u8 = 10;
    let b: &amp;u8 = &amp;a;
    println!(&quot;Valor de a: {}\nvalor de a a partir de b:{}&quot;, a, b)
}
</code></pre></pre>
<p>No exemplo acima a variável 'b' faz referência a variável 'a' do tipo <code>u8</code>. </p>
<p>Podemos também ter referências mutáveis, porém existem duas regras, a primeira é a variável referênciada também deve ser mutável, assim podemos alterar o valor de uma variável a partir de outra que a referência, mas para isso realizamos uma &quot;desreferênciação&quot; com o caractere <code>*</code></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut a: u8 = 10;
    let b: &amp;mut u8 = &amp;mut a;
    *b = 20u8;
    println!(&quot;Valor de a: {}&quot;, a);
}
</code></pre></pre>
<p>A outra regra é, só podemos ter uma única referência mutável para a variável:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut a: u8 = 10;
    let b: &amp;mut u8 = &amp;mut a;
    let _c: &amp;mut u8 = &amp;mut a;
    *b = 20u8;
    println!(&quot;Valor de a: {}&quot;, a);
}
</code></pre></pre>
<p>Ao tentar compilar o código acima temos o seguinte erro:</p>
<pre><code class="language-bash">error[E0499]: cannot borrow `a` as mutable more than once at a time
 --&gt; main.rs:4:23
  |
3 |     let b: &amp;mut u8 = &amp;mut a;
  |                      ------ first mutable borrow occurs here
4 |     let _c: &amp;mut u8 = &amp;mut a;
  |                       ^^^^^^ second mutable borrow occurs here
5 |     *b = 20u8;
  |     --------- first borrow later used here

error: aborting due to previous error
</code></pre>
<p>Com isso entramos no sistema de ownership do Rust, que daremos continuidade na próxima parte desse 4Noobs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ownership"><a class="header" href="#ownership">Ownership</a></h1>
<p>Ownership é o método que Rust usa para o seu gerenciamento de memória, basicamente enquanto algum <a href="https://en.wikipedia.org/wiki/Scope_(computer_science)">escopo</a> do código tem aquele pedaço de memória ele é da nossa aplicação, quando esse pedaço de memória sai deste escopo ela é devolvida para o <a href="https://simple.wikipedia.org/wiki/Operating_system">Sistema Operacional</a>.</p>
<p>Vamos entender um pouco melhor como funciona o escopo de uma variável.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {

    let a = 10;
    if a == 10 {
        let b = 1;
        /*
            Neste ponto do código as variáveis 'a' e 'b' existem
        */
    }
    /*
        a partir deste ponto não é possível acessar a variável 'b',
        pois ela esta fora de escopo
    */
    println!(&quot;Valor de b {}&quot;, b);
}
</code></pre></pre>
<p>Ao tentar compilar o código acima temos o seguinte erro:</p>
<pre><code class="language-bash">error[E0425]: cannot find value `b` in this scope
  --&gt; main.rs:14:31
   |
14 |     println!(&quot;Valor de b {}&quot;, b);
   |                               ^ help: a local variable with a similar name exists: `a`

error: aborting due to previous error
</code></pre>
<p>Neste caso 'b' pertence a um escopo menor do que 'a', a partir do momento que sai do bloco <code>if</code> a variável 'b' desaparece.</p>
<p>E como isso funciona no sistema de ownership? Para explicar isso iremos utilizar o tipo que aprendemos no começo deste módulo, as <a href="intermediary-01/./01-strings.html">Strings</a>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut meu_texto = String::from(&quot;Rust4Noobs&quot;);
    printa_string(meu_texto);
    /*
        Vamos tentar fazer outra coisa com essa String
    */
    meu_texto.push_str(&quot;, é legal!&quot;);
}

fn printa_string(string: String) {
    println!(&quot;{}&quot;, string);
}
</code></pre></pre>
<p>Espera... Não compila, temos o seguinte erro:</p>
<pre><code class="language-bash">error[E0382]: borrow of moved value: `meu_texto`
 --&gt; main.rs:7:5
  |
2 |     let mut meu_texto = String::from(&quot;Rust4Noobs&quot;);
  |         ------------- move occurs because `meu_texto` has type `String`, which does not implement the `Copy` trait
3 |     printa_string(meu_texto);
  |                   --------- value moved here
...
7 |     meu_texto.push_str(&quot;, é legal!&quot;);
  |     ^^^^^^^^^ value borrowed here after move

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
</code></pre>
<p>Vamos entender o que aconteceu aqui.</p>
<p>O tipo <code>String</code> é um &quot;tipo especial&quot;, ele sempre é passado por referência, nunca é feito uma cópia de seu valor, quando chamamos a função <code>printa_string</code> e em seu parâmetro passamos nossa String, a posse de sua memória é transferida para a função, quando a função termina a memória é devolvida para o Sistema Operacional.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut meu_texto = String::from(&quot;Rust4Noobs&quot;);
    printa_string(meu_texto);
    /*
        Vamos tentar fazer outra coisa com essa String
    */
    meu_texto.push_str(&quot;, é legal!&quot;);
}

fn printa_string(string: String) {
    println!(&quot;{}&quot;, string);
} //a partir daqui a memória foi devolvida para o sistema
</code></pre></pre>
<p>Mas se ainda quisermos utilizar a variável <code>meu_texto</code>? Podemos fazer a função <code>printa_string</code> retornar a String passada por argumento e pegar o ownership de volta.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut meu_texto = String::from(&quot;Rust4Noobs&quot;);
    meu_texto = printa_string(meu_texto);
    meu_texto.push_str(&quot;, é legal!&quot;);
    println!(&quot;{}&quot;, meu_texto);
}

fn printa_string(string: String) -&gt; String {
    println!(&quot;{}&quot;, string);
    string
}
</code></pre></pre>
<p>Agora o código ira compilar, todavia esta não é a única maneira de fazer isso, lembra dos <a href="intermediary-01/./02-pointers-intro.html">ponteiros</a>? Vamos utilizar aqui.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut meu_texto = String::from(&quot;Rust4Noobs&quot;);
    printa_string(&amp;meu_texto);
    meu_texto.push_str(&quot;, é legal!&quot;);
    println!(&quot;{}&quot;, meu_texto);
}

fn printa_string(string: &amp;String) {
    println!(&quot;{}&quot;, string);
}
</code></pre></pre>
<p>E também funcionou, por enquanto vamos tentar pensar da seguinte maneira, como eu utilizei o ponteiro, eu emprestei a esta função a variável, ela fez o que tinha que fazer e me devolveu. Não perdemos o ownership da variável.</p>
<p>Utilizando esta estratégia de <a href="https://en.wikipedia.org/wiki/Reference_(computer_science)">passagem por referência</a> conseguimos utilizar algumas outras coisas como as referências mutáveis, modificar o valor sem perder o ownership</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut meu_texto = String::from(&quot;Rust4Noobs&quot;);
    printa_string(&amp;meu_texto);
    adiciona_texto(&amp;mut meu_texto);
    println!(&quot;{}&quot;, meu_texto);
}

fn printa_string(string: &amp;String) {
    println!(&quot;{}&quot;, string);
}

fn adiciona_texto(string: &amp;mut String) {
    string.push_str(&quot;, é legal!&quot;);
}
</code></pre></pre>
<p>E temos sucesso novamente. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tuplas"><a class="header" href="#tuplas">Tuplas</a></h1>
<p>Aprendemos sobre <a href="intermediary-01/../basic/09-arrays.html">arrays</a> no módulo básico, agora iremos falar sobre as tuplas.</p>
<p>Tuplas é uma &quot;coleção&quot; de dados de tipos diferentes, em uma tupla podemos ter um <code>u8</code>, uma <code>String</code>, um <code>char</code>... Todos juntos, sua declaração é feita da seguinte maneira <code>let tuple: (tipo1, tipo2, tipo3...) = (valor1, valor2, valor3...)</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let tuple: (u8, i32, String, char) = (10, 25, String::from(&quot;Rust4noobs&quot;), 'a');
    println!(&quot;{:?}&quot;, tuple);
}
</code></pre></pre>
<p>E agora, ainda utilizando o exemplo acima, como eu faço para acessar o valor <code>i32</code> da tupla? Ou seja, o segundo item. Assim como no array começamos a contagem por <code>0</code> nas tuplas também fazemos isso, porém ao invés de utilizarmos os colchetes para acessar, utilizamos o <code>.0</code></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
              //0,  1, , 2     , 3
    let tuple: (u8, i32, String, char) = (10, 25, String::from(&quot;Rust4Noobs&quot;), 'a');
    println!(&quot;Valor i32: {}&quot;, tuple.1);
}
</code></pre></pre>
<p>Acessamos o valor i32 e escrevemos ele na saída principal.</p>
<p>Na parte sobre <a href="intermediary-01/./03-ownership.html">ownership</a> utilizamos da estratégia de retornar o que foi passado por parâmetro para não perdemos a posse de memória da variável, podemos fazer isso com tuplas também.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let texto1 = String::from(&quot;Rust&quot;);
    let texto2 = String::from(&quot;4Noobs&quot;);
    let (mut devolve1, mut devolve2) = printa_duas_strings(texto1, texto2);
    devolve1.push_str(&quot; qualquercoisasópraterexemplo&quot;);
    devolve2.push_str(&quot; sérionaotiveideianenhuma&quot;);
    println!(&quot;{}&quot;, devolve1);
    println!(&quot;{}&quot;, devolve2);
}

fn printa_duas_strings(texto1: String, texto2: String) -&gt; (String, String) {
    println!(&quot;{}&quot;, texto1);
    println!(&quot;{}&quot;, texto2);
    (texto1, texto2)
}
</code></pre></pre>
<p>Conseguimos utilizar a mesma estratégia de retornar os parâmetros para não perder o ownership com uma tupla.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="slices"><a class="header" href="#slices">Slices</a></h1>
<p>Nesta parte do 4Noobs, iremos falar sobre os <a href="https://doc.rust-lang.org/rust-by-example/primitives/array.html">Slices</a> e para isso iremos utilizar <a href="intermediary-01/./01-strings.html">String</a> <del>sim, ainda falando sobre esse tipo zZzzzZZZ</del>, claro não é algo exclusivo de String, é apenas um pedaço de algo <del>literalmente</del>, mas como já falamos sobre este cara, vamos usar ele mesmo. <del>Não eu não estou com preguiça</del>.</p>
<p>Temos o seguinte trecho de código:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let texto: String = String::from(&quot;Rust 4 Noobs&quot;);
}
</code></pre></pre>
<p>A partir da String acima, eu quero pegar os 4 primeiros caracteres desta String, como faríamos isso? Utilizaríamos um <code>slice</code>, e com isso vamos ver outro modo de representar uma String.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let texto: String = String::from(&quot;Rust 4 Noobs&quot;);
    let slice = quatro_primeiros(&amp;texto);
    println!(&quot;{}&quot;, slice);
}

fn quatro_primeiros(texto: &amp;String) -&gt; &amp;str {
    &amp;texto[0..4]
}
</code></pre></pre>
<p>Para criar um <code>slice</code> utilizamos os colchetes, e dentro dos colchetes informamos o valor <code>de</code> e o valor <code>até</code>, deste modo criamos um slice da nossa String. Vamos entrar com outro exemplo agora, vamos achar o primeiro espaço e retornar a primeira palavra, com algumas coisas que já vimos até aqui:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let texto: String = String::from(&quot;Rust 4 Noobs&quot;);
    let slice = primeira_palavra(&amp;texto);
    println!(&quot;{}&quot;, slice);
}

fn primeira_palavra(texto: &amp;String) -&gt; &amp;str {
    let bytes = texto.as_bytes();
    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' { //b' ' transforma o espaço em um byte
            return &amp;texto[0..i]
        }
    }
    &amp;texto[..] //caso não ache retorna a string inteira como um slice
}
</code></pre></pre>
<h1 id="referência-ausente"><a class="header" href="#referência-ausente">referência &quot;ausente&quot;</a></h1>
<p>Sendo sincero não encontrei um modo melhor de traduzir &quot;dangling reference&quot;, mas ela ocorre quando tentamos retornar uma referência de algo que já foi devolvido ao Sistema Operacional. Vamos utilizar o nosso primeiro exemplo para demonstrar, vamos remover a passagem por referência da nossa função, pegar o ownership e tentar devolver o <code>slice</code></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let texto: String = String::from(&quot;Rust 4 Noobs&quot;);
    let slice = quatro_primeiros(&amp;texto);
    println!(&quot;{}&quot;, slice);
}

fn quatro_primeiros(texto: String) -&gt; &amp;str {
    &amp;texto[0..4]
}
</code></pre></pre>
<p>Ao tentar compilar o código acima, tentamos devolver um pedaço da String que foi passada como parâmetro, porém quando esta função sai do escopo devolvemos a memória para o Sistema Operacional, então o slice iria apontar para nada, lembra que Rust é <code>memory safe</code>? Então, o compilador não deixa compilar nos devolvendo o seguinte erro</p>
<pre><code class="language-bash">error[E0106]: missing lifetime specifier
 --&gt; main.rs:7:39
  |
7 | fn quatro_primeiros(texto: String) -&gt; &amp;str {
  |                                       ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value with an elided lifetime, but the lifetime cannot be derived from the arguments
help: consider using the `'static` lifetime
  |
7 | fn quatro_primeiros(texto: String) -&gt; &amp;'static str {
  |                                       ~~~~~~~~

error: aborting due to previous error
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="entrada-de-dados"><a class="header" href="#entrada-de-dados">Entrada de dados</a></h1>
<p>Agora que conhecemos as <a href="intermediary-01/./01-strings.html">Strings</a>, sabemos sobre os ponteiros, sistema de ownership podemos falar sobre a entrada de dados pelo terminal em nossa aplicação. Isso não foi passado antes, pois precisávamos entender alguns conceitos antes de utilizarmos o input de dados.</p>
<p>Para aceitarmos os dados a partir do console, usamos o seguinte código</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut string = String::new();
    println!(&quot;Entre com o seu texto: &quot;);
    std::io::stdin().read_line(&amp;mut string).unwrap();
    println!(&quot;Voce digitou {}&quot;, string);
}
</code></pre></pre>
<p>Da biblioteca padrão do Rust utilizamos o <code>stdin</code>, ou seja, a entrada padrão de dados, precisamos de um <a href="https://en.wikipedia.org/wiki/Data_buffer">buffer</a>, neste caso utilizamos uma <code>String</code> mutável e vazia, para isso utilizamos o método <code>new</code> e passamos esse <code>buffer</code> como uma referência mutável para o método <code>read_line</code>, o método <code>unwrap</code> ira fazer a nossa aplicação parar caso a leitura da entrada padrão falhe.</p>
<h2 id="parse"><a class="header" href="#parse">Parse</a></h2>
<p>Agora que sabemos como ler uma entrada do usuário, vamos aprender como transformar este texto em um tipo inteiro, por exemplo.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut string = String::new();
    println!(&quot;Entre com um número: &quot;);
    std::io::stdin().read_line(&amp;mut string).unwrap();
    let numero = string.trim().parse::&lt;i32&gt;().unwrap();
    if numero &gt;= 10 {
        println!(&quot;Seu número é maior ou igual a 10&quot;);
    } else {
        println!(&quot;Seu número é menor que 10&quot;);
    }
}
</code></pre></pre>
<p>Lembra do método <code>trim</code> sem ele não iramos conseguir fazer esta conversão. O método <code>parse</code> é o responsável por converter de um texto para um tipo inteiro, ou um tipo com ponto flutuante. O tipo entre o sinal de menor e maior é o tipo que iremos fazer o parse.</p>
<p>Não iremos nos aprofundar tanto neste ponto, mostrando exemplos com todos os tipos de numéricos, mas iremos demonstrar essa conversão com uma inferência de tipo.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut string = String::new();
    println!(&quot;Entre com um número: &quot;);
    std::io::stdin().read_line(&amp;mut string).unwrap();
    let numero = string.trim().parse().unwrap();
    numero_maior_igual_a_dez(numero);
}

fn numero_maior_igual_a_dez(numero: i32) {
    if numero &gt;= 10 {
        println!(&quot;Seu número é maior ou igual a 10&quot;);
    } else {
        println!(&quot;Seu número é menor que 10&quot;);
    }
}
</code></pre></pre>
<p>O compilador do Rust é inteligente o suficiente para saber que estamos fazendo um parse para o tipo <code>i32</code>, por estarmos chamando a função <code>numero_maior_igual_a_dez</code> que recebe um <code>i32</code> por parâmetro, e este parâmetro é a variável que ira receber o valor do parse.</p>
<h3 id="casting"><a class="header" href="#casting">Casting</a></h3>
<p>Se lembra da parte sobre <a href="intermediary-01/../basic/09-arrays.html">arrays</a> quando utilizamos o seguinte trecho de código</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>...
    let mut array: [u8; 7] = [0; 7];
    for i in 0..array.len() {
        array[i] = i as u8 + 10u8;
    }
...
<span class="boring">}
</span></code></pre></pre>
<p>Aquela palavra <code>as</code> foi a responsável em transformar um tipo <code>usize</code> em um tipo <code>u8</code>, chamamos este tipo de operação de <a href="https://en.wikipedia.org/wiki/Type_conversion">casting</a>, nem sempre este tipo de operação funciona, como nosso exemplo era um número bem pequeno conseguimos converter para um tipo <code>u8</code>, mas se o valor fosse maior que 255 esta conversão iria falhar, pois ocupara mais do que 1 byte. Então tome cuidado ao utilizar este tipo de operação, exemplo de código que ira falhar, nos dando um resultado não esperado.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a: usize = 10000;
    let b: u8 = a as u8;
    println!(&quot;Valor convertido: {}&quot;, b);
}
</code></pre></pre>
<p>Lembrando este exemplo é apenas para tipos primitivos, futuramente iremos aprender outros tipos e iremos ver que nem sempre é possível realizar esta operação.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercícios-1"><a class="header" href="#exercícios-1">Exercícios</a></h1>
<p>Esta na hora de praticar com base no que vimos neste módulo.</p>
<p>1 - Faça um programa que receba um número de no máximo 255 como entrada do usuário e informe em qual grau o numero esta encaixado, conforme as especificações:</p>
<ul>
<li>1° grau entre 0 e 50</li>
<li>2° grau entre 51 e 120</li>
<li>3° grau entre 121 e 200</li>
<li>4° grau acima de 200</li>
</ul>
<p>2 - Faça um programa que tenha a String &quot;Rust4Noobs&quot; e receba do usuário outra String que sera adicionada a String já existente. E escreva no console.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intermediario-2"><a class="header" href="#intermediario-2">Intermediario 2</a></h1>
<p>Vamos a segunda parte do módulo intermediario, o módulo foi divido em duas partes por conta do conteúdo do <a href="intermediary-02/../intermediary-01">Intermediario 1</a> não ser tão basico e nem tão &quot;intermediario&quot;, nesta parte iremos falar sobre: struct, enum, match, traits, Option, Result, &quot;if let&quot;, generics e algumas colecoes</p>
<p>Roadmap:</p>
<ul>
<li><a href="intermediary-02/./01-structs.html">Struct</a></li>
<li><a href="intermediary-02/./02-enums.html">Enum</a></li>
<li><a href="intermediary-02/./03-match.html">Match</a></li>
<li><a href="intermediary-02/./04-modules.html">Modulos</a></li>
<li><a href="intermediary-02/./05-generics.html">Generics</a></li>
<li><a href="intermediary-02/./06-traits.html">Traits</a></li>
<li><a href="intermediary-02/./07-option.html">Enum especial Option</a></li>
<li><a href="intermediary-02/./08-vec.html">Coleções: Vec</a></li>
<li><a href="intermediary-02/./09-hashset.html">Coleções: HashSet</a></li>
<li><a href="intermediary-02/./10-hashmap.html">Coleções: HashMap</a></li>
<li><a href="intermediary-02/./11-result.html">Tratamento de erros</a></li>
<li><a href="intermediary-02/./12-panic.html">Macro panic!</a></li>
<li><a href="intermediary-02/./13-tests.html">Testes</a></li>
<li><a href="intermediary-02/./14-snake.html">Mini projeto - Snake Game</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structs"><a class="header" href="#structs">Structs</a></h1>
<p>Struct no modo mais simples de se falar é uma estrutura de valores em &quot;uma única variável&quot;. Não consigo pensar em um modo mais fácil de explicar com palavras o que seria uma &quot;struct&quot;, sua declaração é simples ela segue o seguinte padrão <code>struct Nome { campos }</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Cliente {
    nome: String,
    ano_de_nascimento: u16,
    documento: String,
}
<span class="boring">}
</span></code></pre></pre>
<p>O modo de declaração dos campos/atributos de uma struct lembra bastante o de um <a href="https://en.wikipedia.org/wiki/JSON">json</a>, para criarmos uma variável de uma struct podemos fazer da seguinte maneira:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Cliente {
</span><span class="boring">    nome: String,
</span><span class="boring">    ano_de_nascimento: u16,
</span><span class="boring">    documento: String,
</span><span class="boring">}
</span>//--declaração da estrutura Cliente

fn main() {
    let cliente: Cliente = Cliente {
        nome: String::from(&quot;Paulo&quot;),
        ano_de_nascimento: 1999,
        documento: String::from(&quot;Onde?&quot;)
    };
}
</code></pre></pre>
<p>Podemos acessar os campos da variável utilizando apenas um &quot;.nome_do_campo&quot;.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Cliente {
</span><span class="boring">    nome: String,
</span><span class="boring">    ano_de_nascimento: u16,
</span><span class="boring">    documento: String,
</span><span class="boring">}
</span>//--declaração da estrutura Cliente

fn main() {
    let cliente = Cliente {
        nome: String::from(&quot;Paulo&quot;),
        ano_de_nascimento: 1999,
        documento: String::from(&quot;Onde?&quot;)
    };
    println!(&quot;Nome do cliente: {}&quot;, cliente.nome);
}
</code></pre></pre>
<h2 id="declarando-comportamento-para-uma-struct"><a class="header" href="#declarando-comportamento-para-uma-struct">Declarando comportamento para uma Struct</a></h2>
<p>Em Rust uma struct pode ter funções associadas a ela, essas funções são chamadas de métodos, aqui temos uma das características de <a href="intermediary-02/">Programação Orientada a Objetos</a> no Rust, como a linguagem é de multi-paradigmas temos alguns recursos desse modo de programação disponível.</p>
<p>Para implementarmos métodos para a struct <code>Cliente</code> utilizamos a palavra reservada <code>impl</code> seguida do nome da estrutura <code>impl Cliente { implementações }</code>, vamos começar com a implementação de um método estático para nos auxiliar na criação de variáveis do tipo <code>Cliente</code>.</p>
<pre><pre class="playground"><code class="language-rust">struct Cliente {
    nome: String,
    ano_de_nascimento: u16,
    documento: String,
}

impl Cliente {
    fn new(nome: String, ano_de_nascimento: u16, documento: String) -&gt; Self {
        Self {
            nome: nome,
            ano_de_nascimento,
            /*
                Como o atributo tem o mesmo nome do parâmetro/variável eu não preciso colocar o padrão chave:valor
            */
            documento
        }
    }
}

fn main() {
    let cliente = Cliente::new(String::from(&quot;Paulo&quot;), 1999, String::from(&quot;Onde?&quot;));
    println!(&quot;Nome do cliente: {}&quot;, cliente.nome);
}
</code></pre></pre>
<p>A palavra <code>Self</code> com 'S' maiúsculo é um modo de falar que estamos se referindo a própria struct que esta sendo implementada.</p>
<p>Temos também métodos que dependem de uma <a href="https://en.wikipedia.org/wiki/Instance_(computer_science)">instância</a> da struct, para este tipo de métodos utilizamos a própria struct utilizando a palavra <code>self</code> com 's' minúsculo como parâmetro do método, pode ser uma referência mutável, imutável ou pode não ser referência, porém, não sendo uma referência perdemos o ownership da struct e sua memória é liberada.</p>
<pre><pre class="playground"><code class="language-rust">struct Cliente {
    nome: String,
    ano_de_nascimento: u16,
    documento: String,
}

impl Cliente {
    fn new(nome: String, ano_de_nascimento: u16, documento: String) -&gt; Self {
        Self {
            nome: nome,
            ano_de_nascimento,
            /*
                Como o atributo tem o mesmo nome do
                parâmetro/variável eu não preciso
                colocar o padrão chave:valor
            */
            documento
        }
    }

    fn diz_oi(&amp;self) {
        println!(&quot;{} disse oi&quot;, self.nome);
    }

    fn diz_tchau(self) {
        println!(&quot;{} disse tchau e foi embora&quot;, self.nome);
    }

    fn mudar_nome(&amp;mut self, novo_nome: String) {
        //para utilizar este método a instância de
        //cliente deve ser mutável
        self.nome = novo_nome;
    }
}

fn main() {
    let mut cliente = Cliente::new(String::from(&quot;Paulo&quot;), 1999, String::from(&quot;Onde?&quot;));
    cliente.diz_oi();
    cliente.mudar_nome(String::from(&quot;Novo nome&quot;));
    cliente.diz_oi();
    cliente.diz_tchau(); //a partir daqui a memória deste               //cliente foi liberada não conseguimos mais utilizar
}
</code></pre></pre>
<p>Caso tentarmos utilizar a instância de cliente após a chamada do método <code>diz_tchau</code> teremos o seguinte erro</p>
<pre><code class="language-bash">  --&gt; main.rs:42:5
   |
37 |     let mut cliente = Cliente::new(String::from(&quot;Paulo&quot;), 1999, String::from(&quot;Onde?&quot;));
   |         ----------- move occurs because `cliente` has type `Cliente`, which does not implement the `Copy` trait
...
41 |     cliente.diz_tchau(); //a partir daqui a memória deste
   |             ----------- `cliente` moved due to this method call
42 |     cliente.diz_oi();         //cliente foi liberada não conseguimos mais utilizar
   |     ^^^^^^^ value borrowed here after move
   |
note: this function takes ownership of the receiver `self`, which moves `cliente`
  --&gt; main.rs:25:18
   |
25 |     fn diz_tchau(self) {
   |                  ^^^^

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enum"><a class="header" href="#enum">Enum</a></h1>
<p>Afinal para que serve um enum?</p>
<p>Um enum é uma forma de declarar constantes, de forma mais semântica, sua declaração é feita da seguinte maneira <code>enum Nome { valores }</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Uf {
    Sp,
    Rj,
    Ce,
}
<span class="boring">}
</span></code></pre></pre>
<p>Os enums em Rust, podem também armazenar valores de forma parecida com uma <a href="intermediary-02/../intermediary-01/04-tuples.html">tupla</a>, mas o modo de recuperar o valor sera mais explicado com mais detalhes na próxima parte.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Uf {
    Sp(String),
    Rj(String),
    Ce(String),
}
<span class="boring">}
</span></code></pre></pre>
<p>Por enquanto vamos fazer a seguinte alteração neste <code>enum</code> para conseguirmos escrever no console o valor do Enum</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
enum Uf {
    Sp(String),
    Rj(String),
    Ce(String),
}
<span class="boring">}
</span></code></pre></pre>
<p>Esta alteração que fizemos também pode ser aplicada as <a href="intermediary-02/./01-structs.html">structs</a>, para tirarmos proveito desta modificação iremos usar o macro <code>println!</code> da seguinte maneira.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum Uf {
</span><span class="boring">   Sp(String),
</span><span class="boring">   Rj(String),
</span><span class="boring">   Ce(String),
</span><span class="boring">}
</span>//--declaração do enum
fn main() {
    let uf = Uf::Sp(String::from(&quot;São Paulo&quot;));
    println!(&quot;{:?}&quot;, uf);
    println!(&quot;{:#?}&quot;, uf);
}
</code></pre></pre>
<p>Este modo de uso ira escrever no console o modo em que a estrutura foi declarada, tanto para os enums quanto para as <a href="intermediary-02/./01-structs.html">structs</a>.</p>
<h2 id="métodos-em-enums"><a class="header" href="#métodos-em-enums">Métodos em enums.</a></h2>
<p>Também conseguimos implementar métodos para nossos enums, do mesmo modo que fazemos com as <code>structs</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum Uf {
</span><span class="boring">   Sp(String),
</span><span class="boring">   Rj(String),
</span><span class="boring">   Ce(String),
</span><span class="boring">}
</span>//--Declaração do enum
impl Uf {
    fn retorna_sp() -&gt; Self {
        Self::Sp(String::from(&quot;São Paulo&quot;))
    }

    fn quem_sou_eu(&amp;self) {
        todo!()
    }
}

fn main() {
    let uf = Uf::retorna_sp();
    println!(&quot;{:?}&quot;, uf);
    println!(&quot;{:#?}&quot;, uf);
}
</code></pre></pre>
<p>Na implementação acima temos o método <code>retorna_sp</code> que ira retornar um enum já com o valor preenchido, e temos também o método <code>quem_sou_eu</code> que iremos implementar na próxima parte deste 4Noobs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="match"><a class="header" href="#match">Match</a></h1>
<p>Em Rust não temos a estrutura de decisão <a href="https://en.wikipedia.org/wiki/Switch_statement">switch</a>, em seu lugar temos a expressão <code>match</code>, o seu comportamento é parecido, porém, com alguns recursos a mais. Vamos retomar aquele código dos <a href="intermediary-02/./02-enums.html">enums</a>.</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
enum Uf {
    Sp(String),
    Rj(String),
    Ce(String),
}

impl Uf {
    fn retorna_sp() -&gt; Self {
        Self::Sp(String::from(&quot;São Paulo&quot;))
    }

    fn quem_sou_eu(&amp;self) {
        todo!()
    }
}

fn main() {
    let uf = Uf::retorna_sp();
    println!(&quot;{:?}&quot;, uf);
    println!(&quot;{:#?}&quot;, uf);
}
</code></pre></pre>
<p>Ficamos de implementar o método <code>quem_sou_eu</code> de propósito, nele iremos utilizar a estrutura de decisão <code>match</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum Uf {
</span><span class="boring">    Sp(String),
</span><span class="boring">    Rj(String),
</span><span class="boring">    Ce(String),
</span><span class="boring">}
</span>//--declaração do enum
impl Uf {
<span class="boring">    fn retorna_sp() -&gt; Self {
</span><span class="boring">        Self::Sp(String::from(&quot;São Paulo&quot;))
</span><span class="boring">    }
</span>    //--outros métodos
    fn quem_sou_eu(&amp;self) {
        match self {
            Uf::Sp(_) =&gt; println!(&quot;Eu sou São Paulo&quot;),
        }
    }
}

fn main() {
    let uf = Uf::retorna_sp();
    uf.quem_sou_eu();
}
</code></pre></pre>
<p>Caso tentarmos compilar o código, teremos o seguinte erro:</p>
<pre><code class="language-bash">error[E0004]: non-exhaustive patterns: `&amp;Rj(_)` and `&amp;Ce(_)` not covered
  --&gt; main.rs:14:15
   |
2  | / enum Uf {
3  | |     Sp(String),
4  | |     Rj(String),
   | |     -- not covered
5  | |     Ce(String),
   | |     -- not covered
6  | | }
   | |_- `Uf` defined here
...
14 |           match self {
   |                 ^^^^ patterns `&amp;Rj(_)` and `&amp;Ce(_)` not covered
   |
   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms
   = note: the matched value is of type `&amp;Uf`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0004`.
</code></pre>
<p>O porquê deste erro?</p>
<p>Rust nos obriga a cobrir todos os casos que podem acontecer. Para isso vamos fazer a seguinte alteração.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum Uf {
</span><span class="boring">    Sp(String),
</span><span class="boring">    Rj(String),
</span><span class="boring">    Ce(String),
</span><span class="boring">}
</span>//--declaração do enum
impl Uf {
<span class="boring">    fn retorna_sp() -&gt; Self {
</span><span class="boring">        Self::Sp(String::from(&quot;São Paulo&quot;))
</span><span class="boring">    }
</span>    //--outros métodos
    fn quem_sou_eu(&amp;self) {
        match self {
            Uf::Sp(_) =&gt; println!(&quot;Eu sou São Paulo&quot;),
            Uf::Rj(_) =&gt; println!(&quot;Eu sou Rio de Janeiro&quot;),
            Uf::Ce(_) =&gt; println!(&quot;Eu sou Ceará&quot;),
        }
    }
}

fn main() {
    let uf = Uf::retorna_sp();
    uf.quem_sou_eu();
}
</code></pre></pre>
<p>Agora nosso código ira rodar, mas reparem que eu posso criar uma instância de <code>enum</code> com um valor e o código se repete nos 3 casos. Eu posso melhorar isso um pouco, realizando a troca do '_' por um nome, e também posso deixar todos no mesmo 'match' utilizando um pipe '|'.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum Uf {
</span><span class="boring">    Sp(String),
</span><span class="boring">    Rj(String),
</span><span class="boring">    Ce(String),
</span><span class="boring">}
</span>//--declaração do enum
impl Uf {
<span class="boring">    fn retorna_sp() -&gt; Self {
</span><span class="boring">        Self::Sp(String::from(&quot;São Paulo&quot;))
</span><span class="boring">    }
</span>    //--outros métodos
    fn quem_sou_eu(&amp;self) {
        match self {
            Uf::Sp(nome) | Uf::Rj(nome) | Uf::Ce(nome) =&gt; println!(&quot;Eu sou {}&quot;, nome),
        }
    }
}

fn main() {
    let uf = Uf::retorna_sp();
    uf.quem_sou_eu();
}
</code></pre></pre>
<p>E temos o mesmo resultado. Porém se tivermos várias e várias opções e eu não precisar capturar os valores e terem a mesma tratativa. Porém, caso quisermos utilizar o mesmo modo acima e tivermos enum com quantidade de valores diferentes ou incompatíveis precisamos ignorar todos os valores não correspondentes para isso usamos o '_'.</p>
<pre><pre class="playground"><code class="language-rust">enum Repositorio {
    Este(String, u16),
    Outros(String, u16, u8),
}

fn main() {
    let url_rust4noobs = String::from(&quot;https://github.com/pgjbz/rust4noobs&quot;);
    let qtd_stars_atuais_rust4noobs: u16 = 22;
    let url_4noobs = String::from(&quot;https://github.com/he4rt/4noobs&quot;);
    let qtd_stars_atuais_4noobs: u16 = 1964;
    let qualquer_numero_so_para_diferenciar: u8 = 20;

    let rust4noobs = Repositorio::Este(url_rust4noobs, qtd_stars_atuais_rust4noobs);
    let _4noobs = Repositorio::Outros(url_4noobs, qtd_stars_atuais_4noobs, qualquer_numero_so_para_diferenciar);

    match rust4noobs {
        Repositorio::Este(url, stars) | Repositorio::Outros(url, stars, _) =&gt; println!(&quot;Repositorio {}, estrelas {}&quot;, url, stars),
    }
}
</code></pre></pre>
<p>Claro podemos quebrar em mais 'match' para não perder essas informações.</p>
<pre><pre class="playground"><code class="language-rust">enum Repositorio {
    Este(String, u16),
    Outros(String, u16, u8),
}

fn main() {
    let url_rust4noobs = String::from(&quot;https://github.com/pgjbz/rust4noobs&quot;);
    let qtd_stars_atuais_rust4noobs: u16 = 22;
    let url_4noobs = String::from(&quot;https://github.com/he4rt/4noobs&quot;);
    let qtd_stars_atuais_4noobs: u16 = 1964;
    let qualquer_numero_so_para_diferenciar: u8 = 20;

    let rust4noobs = Repositorio::Este(url_rust4noobs, qtd_stars_atuais_rust4noobs);
    let _4noobs = Repositorio::Outros(url_4noobs, qtd_stars_atuais_4noobs, qualquer_numero_so_para_diferenciar);

    match rust4noobs {
        Repositorio::Este(url, stars) =&gt; println!(&quot;Repositorio {}, estrelas {}&quot;, url, stars),
        Repositorio::Outros(url, stars, n) =&gt; println!(&quot;Repositorio {}, estrelas {}, numero aleatório para diferenciar {}&quot;, url, stars, n),
    }
}
</code></pre></pre>
<p>E se eu tenho, por exemplo  um <code>u8</code> eu preciso realizar um 'match' para cada possibilidade? Não eu posso fazer um 'match' com o '<em>' novamente, seria como o 'default' do switch, mas lembre-se quando usamos o '</em>' ignoramos o valor.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numero: u8 = 10;
    match numero {
        1 =&gt; println!(&quot;Um&quot;),
        2 =&gt; println!(&quot;Dois&quot;),
        3 =&gt; println!(&quot;Três&quot;),
        _ =&gt; println!(&quot;Qualquer outro numero&quot;)
    }
}
</code></pre></pre>
<p>Com o código acima cobrimos todas as possibilidades possíveis e qualquer valor que não seja 1, 2 ou 3 teremos a mesma tratativa.</p>
<p>A expressão match também pode ser utilizada comparar por uma faixa de valor. Utilizando a o 'match' da seguinte maneira 'inicio..=fim'</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numero = 20;
    match numero {
        0..=9 =&gt; println!(&quot;Menor que 10&quot;),
        _ =&gt; println!(&quot;Igual ou maior que 10&quot;)
    }
}
</code></pre></pre>
<p>Ou podemos também utilizar o match para retornar algum valor de qualquer tipo. Mas todos os pontos de retornos tem que ser do mesmo tipo, ou algum tipo de expressão como <code>continue</code>, <code>return</code>, vamos usar o mesmo exemplo anterior, contudo retornando um boolean e armazenando em uma variável.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numero = 20;
    let menor_que_10 = match numero {
        0..=9 =&gt; true,
        _ =&gt; false
    };
    if menor_que_10 {
        println!(&quot;Menor que 10&quot;);
    } else {
        println!(&quot;Igual ou maior que 10&quot;);
    }
}
</code></pre></pre>
<p>Match é uma estrutura bem poderosa, e seu uso é relativamente simples <del>por enquanto</del></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="módulos"><a class="header" href="#módulos">Módulos</a></h1>
<p>Os módulos são a forma em que o Rust tem para organizar o código, eles podem ser feitos no mesmo arquivo, em arquivos diferentes, ou em até subdiretórios do projeto.</p>
<p>Vamos pegar aquele primeiro exemplo utilizado nas <a href="intermediary-02/./01-structs.html">structs</a> e colocar ele dentro de um módulo, para declarar um módulo fazemos da seguinte maneira <code>mod NomeDoModulo { conteúdo }</code>.</p>
<pre><pre class="playground"><code class="language-rust">mod nota_fiscal {
    struct Cliente {
        nome: String,
        ano_de_nascimento: u16,
        documento: String,
    }

    impl Cliente {
        fn new(nome: String, ano_de_nascimento: u16, documento: String) -&gt; Self {
            Self {
                nome,
                ano_de_nascimento,
                documento
            }
        }
    }
}

fn main() {
    let cliente = Cliente::new(String::from(&quot;Paulo&quot;), 1999, String::from(&quot;Onde?&quot;));
}
</code></pre></pre>
<p>Separamos a struct <code>Cliente</code> em outro módulo, agora vamos tentar compilar este código... Espera temos um erro.</p>
<pre><code class="language-bash">error[E0433]: failed to resolve: use of undeclared type `Cliente`
  --&gt; src/main.rs:20:23
   |
20 |     let mut cliente = Cliente::new(String::from(&quot;Paulo&quot;), 1999, String::from(&quot;Onde?&quot;));
   |                       ^^^^^^^ not found in this scope
   |
help: consider importing this struct
   |
1  | use crate::nota_fiscal::Cliente;
   |

For more information about this error, try `rustc --explain E0433`.
error: could not compile `modulos` due to previous error
</code></pre>
<p>A struct não foi encontrada no escopo. O compilador esta dizendo para importamos o cliente, vamos importar utilizando o que o compilador diz para importar <code>use crate::nota_fiscal::Cliente;</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">mod nota_fiscal {
</span><span class="boring">    struct Cliente {
</span><span class="boring">        nome: String,
</span><span class="boring">        ano_de_nascimento: u16,
</span><span class="boring">        documento: String,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl Cliente {
</span><span class="boring">        fn new(nome: String, ano_de_nascimento: u16, documento: String) -&gt; Self {
</span><span class="boring">            Self {
</span><span class="boring">                nome,
</span><span class="boring">                ano_de_nascimento,
</span><span class="boring">                documento
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span>//--declaração do modulo

use crate::nota_fiscal::Cliente;

fn main() {
    let cliente = Cliente::new(String::from(&quot;Paulo&quot;), 1999, String::from(&quot;Onde?&quot;));
}
</code></pre></pre>
<p>E compilamos... Outro erro.</p>
<pre><code class="language-bash">error[E0603]: struct `Cliente` is private
  --&gt; src/main.rs:19:24
   |
19 | use crate::nota_fiscal::Cliente;
   |                        ^^^^^^^ private struct
   |
note: the struct `Cliente` is defined here
  --&gt; src/main.rs:2:5
   |
2  |     struct Cliente {
   |     ^^^^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `modulos` due to previous error
</code></pre>
<p>Por padrão todas as declarações dentro de um módulo são privadas, para resolvermos este problema utilizamos a palavra <code>pub</code>, vamos adicionar isso tanto para a struct quanto para a implementação do método estático <code>new</code>, porque ele também é privado.</p>
<pre><pre class="playground"><code class="language-rust">mod nota_fiscal {
    pub struct Cliente {
        nome: String,
        ano_de_nascimento: u16,
        documento: String,
    }

    impl Cliente {
        pub fn new(nome: String, ano_de_nascimento: u16, documento: String) -&gt; Self {
            Self {
                nome,
                ano_de_nascimento,
                documento
            }
        }
    }
}

//--método main
<span class="boring">use crate::nota_fiscal::Cliente;
</span>
<span class="boring">fn main() {
</span><span class="boring">    let cliente = Cliente::new(String::from(&quot;Paulo&quot;), 1999, String::from(&quot;Onde?&quot;));
</span><span class="boring">    println!(&quot;{} {} {}&quot;, cliente.nome, cliente.ano_de_nascimento, cliente.documento);
</span><span class="boring">}
</span></code></pre></pre>
<p>Os atributos também são privados, caso tentarmos acessar qualquer um deles teremos outro erro de compilação, podemos acessar através de outros métodos públicos, ou deixando os atributos públicos.</p>
<pre><pre class="playground"><code class="language-rust">mod nota_fiscal {
    pub struct Cliente {
        pub nome: String,
        pub ano_de_nascimento: u16,
        pub documento: String,
    }
//--métodos
<span class="boring">    impl Cliente {
</span><span class="boring">        pub fn new(nome: String, ano_de_nascimento: u16, documento: String) -&gt; Self {
</span><span class="boring">            Self {
</span><span class="boring">                nome,
</span><span class="boring">                ano_de_nascimento,
</span><span class="boring">                documento
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span>}

//--método main
<span class="boring">use crate::nota_fiscal::Cliente;
</span>
<span class="boring">fn main() {
</span><span class="boring">    let cliente = Cliente::new(String::from(&quot;Paulo&quot;), 1999, String::from(&quot;Onde?&quot;));
</span>
<span class="boring">    println!(&quot;{} {} {}&quot;, cliente.nome, cliente.ano_de_nascimento, cliente.documento);
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="separando-módulos-em-outros-arquivos"><a class="header" href="#separando-módulos-em-outros-arquivos">Separando módulos em outros arquivos</a></h2>
<p>Não adianta muito criamos módulos para organizar o nosso código e mantermos tudo no mesmo arquivo. Vamos começar criando um arquivo <code>nota_fiscal.rs</code> e jogando o código do Cliente para este arquivo.</p>
<p>A estrutura do nosso projeto fica da seguinte maneira.</p>
<pre><code class="language-bash">.
├── Cargo.lock
├── Cargo.toml
└── src
    ├── main.rs
    └── nota_fiscal.rs
</code></pre>
<p>main.rs</p>
<pre><pre class="playground"><code class="language-rust">mod nota_fiscal;

use crate::nota_fiscal::Cliente;

fn main() {
    let cliente = Cliente::new(String::from(&quot;Paulo&quot;), 1999, String::from(&quot;Onde?&quot;));
    println!(
        &quot;Nome: {}\nAno de nascimento: {}, Documento: {}&quot;,
        cliente.nome, cliente.ano_de_nascimento, cliente.documento
    );
}
</code></pre></pre>
<p>nota_fiscal.rs</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Cliente {
    pub nome: String,
    pub ano_de_nascimento: u16,
    pub documento: String,
}

impl Cliente {
    pub fn new(nome: String, ano_de_nascimento: u16, documento: String) -&gt; Self {
        Self {
            nome,
            ano_de_nascimento,
            documento,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora o projeto dividido. Porém, esta não é a única maneira, podemos utilizar uma pasta com o mesmo nome <code>nota_fiscal</code> e dentro da pasta um arquivo <code>mod.rs</code>, para termos o mesmo efeito.</p>
<p>E teríamos a seguinte estrutura de projeto.</p>
<pre><code class="language-bash">.
├── Cargo.lock
├── Cargo.toml
└── src
    ├── main.rs
    └── nota_fiscal
        └── mod.rs
</code></pre>
<p>O código de <code>nota_fiscal.rs</code> é transferido para <code>mod.rs</code> na pasta <code>nota_fiscal</code> e nada mais é mudado. Temos o mesmo comportamento e o código dividido em módulos.</p>
<h3 id="importando-e-re-exportando-módulos"><a class="header" href="#importando-e-re-exportando-módulos">Importando e re-exportando módulos</a></h3>
<p>Vamos realizar a criação de um módulo chamado <code>pedido</code> dentro de nosso modulo <code>nota_fiscal</code> e dentro do módulo <code>pedido</code> vamos criar um módulo <code>produto</code>.</p>
<p>A estrutura do nosso projeto ficara da seguinte maneira:</p>
<pre><code class="language-bash">.
├── Cargo.lock
├── Cargo.toml
└── src
    ├── main.rs
    └── nota_fiscal
        ├── mod.rs
        └── pedido
            └── mod.rs
</code></pre>
<p>nota_fiscal/mod.rs</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod pedido;

#[derive(Debug)]
pub struct Cliente {
    pub nome: String,
    pub ano_de_nascimento: u16,
    pub documento: String,
}

impl Cliente {
    pub fn new(nome: String, ano_de_nascimento: u16, documento: String) -&gt; Self {
        Self {
            nome,
            ano_de_nascimento,
            documento
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>nota_fiscal/pedido/mod.rs</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use self::produto::Produto;

use super::Cliente;

#[derive(Debug)]
pub struct Pedido&lt;'a&gt; {
    pub cliente: Cliente,
    pub produtos: &amp;'a [Produto]
}

impl&lt;'a&gt; Pedido&lt;'a&gt; {
    pub fn new(cliente: Cliente, produtos: &amp;'a [Produto]) -&gt; Self {
        Self {
            cliente,
            produtos
        }
    }
}

pub mod produto {
    #[derive(Debug)]
    pub struct Produto {
        pub nome: String,
        pub preco: f64
    }

    impl Produto {
        pub fn new(nome: String, preco: f64) -&gt; Self {
            Self {
                nome,
                preco
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>main.rs</p>
<pre><pre class="playground"><code class="language-rust">mod nota_fiscal;

use nota_fiscal::pedido::{Pedido, produto::Produto};

use crate::nota_fiscal::Cliente;

fn main() {
    let cliente = Cliente::new(String::from(&quot;Rust4Noobs&quot;),
1999, String::from(&quot;Q?&quot;));
    let produto = Produto::new(String::from(&quot;4Noobs&quot;), 0f64);
    let produtos = &amp;[produto];
    let pedido = Pedido::new(cliente, produtos);
    println!(&quot;{:#?}&quot;, pedido)
}

</code></pre></pre>
<p>Nesse exemplo temos vários modos de imports, temos um impor com a palavra <code>crate</code> que é a raiz do nosso projeto. Seria o modo de import do mesmo projeto com o path absoluto, temos também o <code>super</code> que é um import a partir do modulo anterior, ou seja, o modulo que declara aquele módulo como tal. Meio confuso, mas conforme vamos praticando fica mais fácil de entender. E temos o import a partir de `nota_fiscal' sendo um modulo do nosso projeto, podemos importar tudo a partir dele, é um modulo que foi declarado em nosso main.</p>
<p>Futuramente iremos utilizar outro modo de projeto que ira utilizar o arquivo <code>lib.rs</code>, onde também podemos declarar os módulos e remover isso do <code>main.rs</code>, com esse arquivo podemos importar conforme o nome do projeto no <code>Cargo.toml</code></p>
<p>lib.rs</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod nota_fiscal;
<span class="boring">}
</span></code></pre></pre>
<p>main.rs</p>
<pre><pre class="playground"><code class="language-rust">use modulos::nota_fiscal::pedido::{Pedido, produto::Produto};

use modulos::nota_fiscal::Cliente;

fn main() {
    let cliente = Cliente::new(String::from(&quot;Rust4Noobs&quot;),
1999, String::from(&quot;Q?&quot;));
    let produto = Produto::new(String::from(&quot;4Noobs&quot;), 0f64);
    let produtos = &amp;[produto];
    let pedido = Pedido::new(cliente, produtos);
    println!(&quot;{:#?}&quot;, pedido)
}
</code></pre></pre>
<p>Nota:</p>
<p>Quando declaramos um módulo interno e utilizamos o &quot;use&quot; como &quot;pub&quot; o modulo interno é exportado como se fosse parte do módulo que o declarou.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generics"><a class="header" href="#generics">Generics</a></h1>
<p>Afinal o que são Generics?</p>
<p>Generics é um modo de reaproveitar um código substituindo um tipo 'T' por um tipo concreto. O compilador de Rust, gera implementações com o tipo concreto para cada uso do generic, ele faz isso para não perdemos performance em tempo de execução.</p>
<h2 id="declaração-de-um-generic"><a class="header" href="#declaração-de-um-generic">Declaração de um Generic</a></h2>
<p>Para declarar um generic. Utilizamos o seguinte padrão <code>struct Nome&lt;T&gt; { implementação }</code></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Cliente&lt;T&gt; {
    nome: String,
    ano_nascimento: u16,
    documento: T
}

fn main() {
    let cliente: Cliente&lt;String&gt; = Cliente::&lt;String&gt; {
        nome: String::from(&quot;Rust4Noobs&quot;),
        ano_nascimento: 2021,
        documento: String::from(&quot;https://github.com/pgjbz/rust4noobs&quot;)
    };

    println!(&quot;{:#?}&quot;, cliente);
}
</code></pre></pre>
<p>Do modo acima, o documento do <code>Cliente</code>, pode ser, uma String, um inteiro, um Enum, outra <code>struct</code>.</p>
<h3 id="implementando-um-método-genérico"><a class="header" href="#implementando-um-método-genérico">Implementando um método genérico.</a></h3>
<p>Continuando o exemplo acima, lembra da parte sobre as <a href="intermediary-02/./01-structs.html">structs</a> onde implementamos o método estático <code>new</code>, como que ficaria para este exemplo usando generic?</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Cliente&lt;T&gt; {
</span><span class="boring">    nome: String,
</span><span class="boring">    ano_nascimento: u16,
</span><span class="boring">    documento: T
</span><span class="boring">}
</span>//--declaração da struct
impl&lt;T&gt; Cliente&lt;T&gt; {
    fn new(nome: String, ano_nascimento: u16, documento: T) -&gt; Self {
        Self {
            nome,
            ano_nascimento,
            documento
        }
    }
}

fn main() {
    // T = String
    let cliente = Cliente::new(
        String::from(&quot;Rust4Noobs&quot;),
        2021,
        String::from(&quot;350.123.123-23&quot;)
    );
    println!(&quot;{:#?}&quot;, cliente);

    // T = u32
    let cliente2 = Cliente::new(
        String::from(&quot;Rust4Noobs&quot;),
        2021,
        35012312323
    );
    println!(&quot;{:#?}&quot;, cliente2);
}
</code></pre></pre>
<p>Eu não necessariamente tenho um limite de quantidade de Generics em uma struct. Por exemplo, e se nessa minha struct de Cliente eu quiser que o <code>ano_nascimento</code> possa ter outro tipo além de <code>u16</code>?</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
struct Cliente&lt;T, U&gt; {
    nome: String,
    ano_nascimento: U,
    documento: T
}

impl&lt;T, U&gt; Cliente&lt;T, U&gt; {
     fn new(nome: String, ano_nascimento: U, documento: T) -&gt; Self {
        Self {
            nome,
            ano_nascimento,
            documento
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="funçõesmétodos-com-generics"><a class="header" href="#funçõesmétodos-com-generics">Funções/Métodos com Generics</a></h3>
<p>Claro generics não apenas para structs, métodos/funções também podem ter. Vamos para o seguinte exemplo.</p>
<pre><pre class="playground"><code class="language-rust">fn maior&lt;T&gt;(lista: &amp;[T]) -&gt; T {
    let mut maior = lista[0];
    for &amp;item in lista {
        if item &gt; maior {
            maior = item;
        }
    }
    maior
}

fn main() {
    let arr: [u8; 4] = [2,4,1,11];
    let maior = maior(&amp;arr);
    println!(&quot;Maior elemento: {}&quot;, maior);
}
</code></pre></pre>
<p>O código acima, esta quaaase funcionando, mas para funcionar precisamos explicar outro conceito, as 'traits'</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="traits"><a class="header" href="#traits">Traits</a></h1>
<p>Na parte sobre <a href="intermediary-02/./05-generics.html">generics</a> deixamos o seguinte código por terminar.</p>
<pre><pre class="playground"><code class="language-rust">fn maior&lt;T&gt;(lista: &amp;[T]) -&gt; T {
    let mut maior = lista[0];
    for &amp;item in lista {
        if item &gt; maior {
            maior = item;
        }
    }
    maior
}

fn main() {
    let arr: [u8; 4] = [2,4,1,11];
    let maior = maior(&amp;arr);
    println!(&quot;Maior elemento: {}&quot;, maior);
}
</code></pre></pre>
<p>Afinal o que falta para esse código funciona? Falta determinamos que 'T' deve implementar algumas traits. O que são essas <code>traits</code>?? Elas são como contratos, um tipo deve implementar certas funções/métodos definidas por essa <code>trait</code>. E como declaramos uma? Seguimos o seguinte padrão <code>trait nome { assinaturas/métodos }</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Pagavel  {
    fn total(&amp;self) -&gt; f64;
}
<span class="boring">}
</span></code></pre></pre>
<p>Assim definimos uma <code>trait</code>, agora precisamos implementar, vamos criar uma <code>struct Pedido</code> que ira implementar essa <code>trait</code>. Para dizer que algo implementa uma <code>trait</code> usamos o seguinte padrão <code>impl NomeTrait for NomeStruct { implementação }</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Pagavel  {
</span><span class="boring">    fn total(&amp;self) -&gt; f64;
</span><span class="boring">}
</span>//--definição trait Pagável

struct Pedido {
    quantidade_items: u8,
    valor_items: f64
}

impl Pagavel for Pedido {
    fn total(&amp;self) -&gt; f64 {
        self.valor_items * self.quantidade_items as f64
    }
}

fn main() {
    let pedido = Pedido {
        quantidade_items: 10,
        valor_items: 10.5
    };
    let total = pedido.total();
    println!(&quot;Total do pedido: {}&quot;, total);
}
</code></pre></pre>
<p>Agora podemos falar que nossa struct de Pedido implementa esta Trait. E agora se vamos utilizar um método genérico que tenha 'T' como parâmetro, porém queremos que 'T' seja pagável. Como faríamos isso? Temos dois modos, sendo eles:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn pagar&lt;T: Pagavel&gt;(pagavel: T) {
    println!(&quot;Valor {} pago&quot;, pagavel.total());
}
<span class="boring">}
</span></code></pre></pre>
<p>Ou com a palavra 'where'</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn pagar&lt;T&gt;(pagavel: T)
where
    T: Pagavel,
{
    println!(&quot;Valor {} pago&quot;, pagavel.total());
}
<span class="boring">}
</span></code></pre></pre>
<p>Então podemos chamar o método genérico pagar passando o pedido como argumento.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Pagavel  {
</span><span class="boring">    fn total(&amp;self) -&gt; f64;
</span><span class="boring">}
</span><span class="boring">struct Pedido {
</span><span class="boring">    quantidade_items: u8,
</span><span class="boring">    valor_items: f64
</span><span class="boring">}
</span><span class="boring">impl Pagavel for Pedido {
</span><span class="boring">    fn total(&amp;self) -&gt; f64 {
</span><span class="boring">        self.valor_items * self.quantidade_items as f64
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">fn pagar&lt;T&gt;(pagavel: T)
</span><span class="boring">where
</span><span class="boring">    T: Pagavel,
</span><span class="boring">{
</span><span class="boring">    println!(&quot;Valor {} pago&quot;, pagavel.total());
</span><span class="boring">}
</span>//--Definição pedido, trait e implementação
fn main() {
    let pedido = Pedido {
        quantidade_items: 10,
        valor_items: 10.5,
    };
    pagar(pedido);
}
</code></pre></pre>
<p>E o programa ira compilar.</p>
<p>Podemos implementar mais de uma trait para algo.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Pagavel  {
</span><span class="boring">    fn total(&amp;self) -&gt; f64;
</span><span class="boring">}
</span><span class="boring">struct Pedido {
</span><span class="boring">    quantidade_items: u8,
</span><span class="boring">    valor_items: f64
</span><span class="boring">}
</span><span class="boring">impl Pagavel for Pedido {
</span><span class="boring">    fn total(&amp;self) -&gt; f64 {
</span><span class="boring">        self.valor_items * self.quantidade_items as f64
</span><span class="boring">    }
</span><span class="boring">}
</span>//--declaração trait pagavel, struct e impl Pagavel
trait Cancelavel {
    fn cancelar(self);
}

impl Cancelavel for Pedido {
    fn cancelar(self) {
        println!(&quot;Pedido com {} itens cancelado&quot;, self.quantidade_items)
    }
}

fn main() {
    let pedido = Pedido {
        quantidade_items: 10,
        valor_items: 10.5,
    };
    pedido.cancelar();
}
</code></pre></pre>
<p>Uma trait pode ter um método já implementado, que pode ou não ser sobrescrito.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Pagavel  {
</span><span class="boring">    fn total(&amp;self) -&gt; f64;
</span><span class="boring">}
</span><span class="boring">struct Pedido {
</span><span class="boring">    quantidade_items: u8,
</span><span class="boring">    valor_items: f64
</span><span class="boring">}
</span><span class="boring">impl Pagavel for Pedido {
</span><span class="boring">    fn total(&amp;self) -&gt; f64 {
</span><span class="boring">        self.valor_items * self.quantidade_items as f64
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">trait Cancelavel {
</span><span class="boring">   fn cancelar(self);
</span><span class="boring">}
</span><span class="boring">impl Cancelavel for Pedido {
</span><span class="boring">   fn cancelar(self) {
</span><span class="boring">       println!(&quot;Pedido com {} itens cancelado&quot;, self.quantidade_items)
</span><span class="boring">   }
</span><span class="boring">}
</span>//--declaração trait pagavel, struct e impl Pagavel e cancelavel

trait Tributavel {
    fn calcular_imposto(&amp;self) -&gt; f64 {
        0.01 * 200.0
    }
}

impl Tributavel for Pedido {}

fn main() {
    let pedido = Pedido {
        quantidade_items: 10,
        valor_items: 10.5,
    };
    pedido.cancelar();
}
</code></pre></pre>
<p>Caso queira sobrescrever a implementação de <code>Tributavel</code> seria feito como a implementação de qualquer outra trait.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Tributavel for Pedido {
    fn calcular_imposto(&amp;self) -&gt; f64 {
        self.valor_items * 0.01
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>E se eu quiser que para implementar <code>Tributavel</code> e <code>Cancelavel</code> eu precise implementar a <code>trait</code> <code>Pagavel</code>? Seria usado uma estratégia parecida com a dos generics <code>trait NomeTrait: TraitQuePrecisaImplementar</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Pagavel {
    fn total(&amp;self) -&gt; f64;
}

trait Cancelavel: Pagavel {
    fn cancelar(self);
}

trait Tributavel: Pagavel {
    fn calcular_imposto(&amp;self) -&gt; f64 {
        0.01 * 200.0
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Do modo acima para implementar <code>Cancelavel</code> ou <code>Tributavel</code> precisamos implementar <code>Pagavel</code>, assim nos dando um novo poder nas implementações, PODER USAR OS MÉTODOS DEFINIDOS EM PAGAVEL.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Cancelavel for Pedido {
    fn cancelar(self) {
        println!(&quot;Pedido custando {} cancelado&quot;, self.total())
    }
}

impl Tributavel for Pedido {
    fn calcular_imposto(&amp;self) -&gt; f64 {
        0.01 * self.total()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>E se eu implementar duas traits com métodos iguais? Não podemos chamar diretamente o método implementado.</p>
<pre><pre class="playground"><code class="language-rust">struct Cachorro {}

trait Animal {
    fn comer(&amp;self);
}

trait Fome {
    fn comer(&amp;self);
}

impl Animal for Cachorro {
    fn comer(&amp;self) {
        println!(&quot;Cachorro comendo... animal&quot;);
    }
}

impl Fome for Cachorro {
    fn comer(&amp;self) {
        println!(&quot;Cachorro comendo por estar com fome&quot;);
    }
}

fn main() {
    let cachorro = Cachorro {};
    cachorro.comer();
}
</code></pre></pre>
<p>Perdão pelo exemplo bobo, mas o código acima daria o seguinte erro.</p>
<pre><code class="language-bash">error[E0034]: multiple applicable items in scope
  --&gt; src/main.rs:25:14
   |
25 |     cachorro.comer();
   |              ^^^^^ multiple `comer` found
   |
</code></pre>
<p>Este erro acontece por termos múltiplas implementações de método com a mesma assinatura. Para chamar o método <code>comer</code> podemos fazer da seguinte maneira <code>trait::metodo(&amp;instância)</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Cachorro {}
</span><span class="boring">trait Animal {
</span><span class="boring">    fn comer(&amp;self);
</span><span class="boring">}
</span><span class="boring">trait Fome {
</span><span class="boring">    fn comer(&amp;self);
</span><span class="boring">}
</span><span class="boring">impl Animal for Cachorro {
</span><span class="boring">    fn comer(&amp;self) {
</span><span class="boring">        println!(&quot;Cachorro comendo... animal&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl Fome for Cachorro {
</span><span class="boring">    fn comer(&amp;self) {
</span><span class="boring">        println!(&quot;Cachorro comendo por estar com fome&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span>//--declarações e implementações
fn main() {
    let cachorro = Cachorro {};
    Animal::comer(&amp;cachorro);
    Fome::comer(&amp;cachorro);
}
</code></pre></pre>
<p>Podemos também implementar traits para tipos já existentes.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Fome {
</span><span class="boring">    fn comer(&amp;self);
</span><span class="boring">}
</span>//--declaração trait de fome
impl Fome for i32 {
    fn comer(&amp;self) {
        println!(&quot;Um numero esta comendo por estar com fome? Isso faz sentido?&quot;)
    }
}

fn main() {
    let a: i32 = 10;
    a.comer();
}
</code></pre></pre>
<p>Claro essa implementação de uma trait teria que fazer sentido, não é mesmo?</p>
<h3 id="traits-já-existentes"><a class="header" href="#traits-já-existentes">Traits já existentes</a></h3>
<p>Em Rust já temos uma boa quantidade de traits já existentes, como, por exemplo, a trait <code>Iterator</code>, com essa <code>trait</code> podemos criar nossas próprias implementações de algo iterável e utilizar os recursos da linguagem, como um loop for, por exemplo.</p>
<pre><pre class="playground"><code class="language-rust">struct Contador {
    contagem: u64
}

impl Iterator for Contador {
    type Item = u64; /*futuramente iremos explicar com mais detalhes o que é isso,
    mas considere que é um modo de usar Generics de uma forma que impedimos múltiplas implementações da mesma trait pra mesma coisa */

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if self.contagem &gt;= 100 {
            None
        } else {
            self.contagem += 1;
            Some(self.contagem)
        }
    }
}

fn main() {
    let contador = Contador { contagem: 0 };

    for i in contador {
        println!(&quot;Numero atual: {}&quot;, i);
    }
}
</code></pre></pre>
<p>Ao executar o código acima teremos a saída.</p>
<pre><code class="language-bash">...
Numero atual: 89
Numero atual: 90
Numero atual: 91
Numero atual: 92
Numero atual: 93
Numero atual: 94
Numero atual: 95
Numero atual: 96
Numero atual: 97
Numero atual: 98
Numero atual: 99
Numero atual: 100
</code></pre>
<h3 id="derive"><a class="header" href="#derive">Derive</a></h3>
<p>O comando <code>#[derive(AlgumaCoisaAqui)]</code>, é um macro para implementação de algumas <code>traits</code>, quando usamos o <code>#[Derive(Debug)]</code> estamos informando ao compilador que queremos que aquela <code>struct/enum</code> ira implementar a trait <code>Debug</code>, porém isso é gerado de forma automática pelo compilador.</p>
<h3 id="voltando-ao-problema-inicial"><a class="header" href="#voltando-ao-problema-inicial">Voltando ao problema inicial.</a></h3>
<p>Agora que entendemos como as <code>traits</code> funcionam vamos retomar o problema que deixamos no fim da <a href="intermediary-02/./05-generics.html">parte anterior</a></p>
<p>Precisamos limitar 'T' para duas <code>traits</code> especificas, essas <code>traits</code> já são existentes na linguagem, sendo elas <code>PartialOrd</code> e <code>Copy</code>, para falar que o argumento precisa implementar mais de uma <code>trait</code> utilizamos o '+', com o seguinte padrão 'T: Trait1 + Trait2 + Trait3....`</p>
<pre><pre class="playground"><code class="language-rust">fn maior&lt;T&gt;(lista: &amp;[T]) -&gt; T
where
    T: PartialOrd + Copy,
{
    let mut maior = lista[0];
    for &amp;item in lista {
        if item &gt; maior {
            maior = item;
        }
    }
    maior
}

fn main() {
    let arr: [u8; 4] = [2, 4, 1, 11];
    let maior = maior(&amp;arr);
    println!(&quot;Maior elemento: {}&quot;, maior);
}
</code></pre></pre>
<p>Ao executar o nosso código finalmente terá sucesso e a seguinte saída no console.</p>
<pre><code class="language-bash">Maior elemento: 11
</code></pre>
<p>Este capítulo sobre <code>traits</code> ficou maior que do eu esperava, mas espero que tenha ficado claro o uso delas e a importância dessa funcionalidade.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enum-especial-optiont"><a class="header" href="#enum-especial-optiont">Enum especial <code>Option&lt;T&gt;</code></a></h1>
<p>Em Rust não temos <strong>nulo</strong>, isso mesmo a linguagem não aplica o <a href="https://en.wikipedia.org/wiki/Null_pointer">conceito de ponteiros nulos</a>, para dizer se algo existe ou não temos o enum <code>Option&lt;T&gt;</code>, este <code>enum</code>, os valores possíveis para este <code>enum</code> são <code>Some(T)</code> e <code>None</code>. Temos alguns métodos neste enum, como <code>is_none</code>, <code>is_some</code>, <code>unwrap</code>, <code>expected</code>, <code>or_else</code>, <code>or</code>.</p>
<h2 id="extraindo-o-valor-de-dentro-de-um-optiont"><a class="header" href="#extraindo-o-valor-de-dentro-de-um-optiont">Extraindo o valor de dentro de um <code>Option&lt;T&gt;</code></a></h2>
<p>Podemos extrair o valor de um <code>Option</code>, pelos métodos, <code>unwrap</code>, <code>expect</code>, por um <code>match</code>, ou por um <code>if let</code>. Cada modo de extrair tem sua peculiaridade, com o <code>unwrap</code> ou com o <code>expect</code> caso o valor seja <code>None</code> temos uma falha na aplicação e sua execução é abortada.</p>
<pre><pre class="playground"><code class="language-rust">struct Cliente {
    nome: String,
    idade: Option&lt;u8&gt;,
}

fn main() {
    let cliente = Cliente {
        nome: &quot;Rust4Noobs&quot;.to_string(),
        idade: None,
    };
    cliente.idade.unwrap();
}
</code></pre></pre>
<p>Ao executar o código acima teremos a execução do programa abortada e a mensagem de erro:</p>
<pre><code class="language-bash">thread 'main' panicked at 'called `Option::unwrap()` on a `None` value', src/main.rs:9:19
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>A diferença entre o <code>unwrap</code>e o <code>expect</code>, é que com o <code>expect</code> podemos definir uma mensagem para este erro</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Cliente {
</span><span class="boring">    nome: String,
</span><span class="boring">    idade: Option&lt;u8&gt;,
</span><span class="boring">}
</span>//--declaração da struct
fn main() {
    let cliente = Cliente {
        nome: &quot;Rust4Noobs&quot;.to_string(),
        idade: None,
    };
    cliente.idade.expect(&quot;idade não informada&quot;);
}
</code></pre></pre>
<p>O código acima causa um erro a mensagem informada.</p>
<pre><code class="language-bash">thread 'main' panicked at 'idade não informada', src/main.rs:8:19
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Mas se quisermos evitar este erro, como fazemos isso? Podemos utilizar os métodos <code>is_none</code> ou <code>is_some</code> para verificar isso.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Cliente {
</span><span class="boring">    nome: String,
</span><span class="boring">    idade: Option&lt;u8&gt;,
</span><span class="boring">}
</span>//--declaração da struct
fn main() {
    let cliente = Cliente {
        nome: &quot;Rust4Noobs&quot;.to_string(),
        idade: Some(21),
    };
    if cliente.idade.is_some() {
        let idade = cliente.idade.unwrap();
        println!(&quot;O cliente {} tem {} anos&quot;, cliente.nome, idade);
    }
}
</code></pre></pre>
<p>Agora temos uma checagem se o valor existe, podemos usar o <code>is_none</code> para adicionar um tratamento para caso a idade não exista.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Cliente {
</span><span class="boring">    nome: String,
</span><span class="boring">    idade: Option&lt;u8&gt;,
</span><span class="boring">}
</span>//--declaração da struct
fn main() {
    let mut cliente = Cliente {
        nome: &quot;Rust4Noobs&quot;.to_string(),
        idade: None,
    };
    if cliente.idade.is_none() {
        println!(&quot;Idade do cliente não informada, favor informar:&quot;);
        let mut buffer = String::new();
        std::io::stdin().read_line(&amp;mut buffer).unwrap();
        cliente.idade = Some(buffer.trim().parse().unwrap());
    }
}
</code></pre></pre>
<p>Mas esse talvez não seja o melhor modo de fazer isso.</p>
<h2 id="extraindo-o-valor-com-um-match"><a class="header" href="#extraindo-o-valor-com-um-match">Extraindo o valor com um match</a></h2>
<p>O operador <a href="intermediary-02/./03-match.html">match</a> pode ser utilizado para <a href="intermediary-02/./02-enums.html">enums</a>, lembra dos <code>enums</code> com valores associados? O <code>Option</code> é um <code>enum</code> com valores associados. Então podemos utilizar o <code>match</code> para chegar se o valor existe.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Cliente {
</span><span class="boring">    nome: String,
</span><span class="boring">    idade: Option&lt;u8&gt;,
</span><span class="boring">}
</span>//--declaração da struct
fn main() {
    let cliente = Cliente {
        nome: &quot;Rust4Noobs&quot;.to_string(),
        idade: None,
    };
    match cliente.idade {
        Some(idade) =&gt; println!(&quot;A idade do cliente {} é {}&quot;, cliente.nome, idade),
        None =&gt; println!(&quot;Idade do cliente {} não foi informada&quot;, cliente.nome)
    }
}
</code></pre></pre>
<p>Claro podemos utilizar de todos os aspectos do <code>match</code> nessa abordagem</p>
<h2 id="operador-if-let"><a class="header" href="#operador-if-let">Operador if let</a></h2>
<p>O operador <code>if let</code> é geralmente usado para tratativas pequenas. Onde realizamos uma validação e já atribuímos o valor a uma variável. Podendo ser feito da seguinte maneira <code>if let Some(nome ou ignora o valor) = expressao teste { codigo } else { se nao }</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Cliente {
</span><span class="boring">    nome: String,
</span><span class="boring">    idade: Option&lt;u8&gt;,
</span><span class="boring">}
</span>//--declaração da struct
fn main() {
    let cliente = Cliente {
        nome: &quot;Rust4Noobs&quot;.to_string(),
        idade: None,
    };
    if let Some(idade) = cliente.idade {
        println!(&quot;A idade do cliente {} é {}&quot;, cliente.nome, idade)
    } else {
        println!(&quot;Idade do cliente {} não foi informada&quot;, cliente.nome)
    }
}
</code></pre></pre>
<p>O código acima tem o mesmo resultado do código com o <code>match</code>, claro o <code>if let</code> também pode retornar algo, assim como o <code>match</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Cliente {
</span><span class="boring">    nome: String,
</span><span class="boring">    idade: Option&lt;u8&gt;,
</span><span class="boring">}
</span>//--declaração da struct
fn main() {
    let cliente = Cliente {
        nome: &quot;Rust4Noobs&quot;.to_string(),
        idade: None,
    };
    let idade = if let Some(idade) =  cliente.idade {
        idade
    } else {
        34 + 35
    };
    println!(&quot;A idade do cliente {} é {}&quot;, cliente.nome, idade);
}
</code></pre></pre>
<p>E temos sucesso, caso o valor exista é retornado o valor dentro de <code>Some(idade)</code> caso não exista é retornado o resultado da soma de <code>34 + 35</code>.</p>
<h2 id="operador-while-let"><a class="header" href="#operador-while-let">Operador while let</a></h2>
<p>O operador <code>if let</code> tem um irmão o <code>while let</code>, seu comportamento é parecido, lembram da implementação de da <a href="intermediary-02/./06-traits.html">trait</a> <code>Iterator</code> que realizamos? Caso não lembre aqui esta ela.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Contador {
    contagem: u64
}

impl Iterator for Contador {
    type Item = u64;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if self.contagem &gt;= 100 {
            None
        } else {
            self.contagem += 1;
            Some(self.contagem)
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Ao implementar essa trait, temos o método <code>next</code> que nos retorna um <code>Option</code>, podemos utilizar esse retorno para ir iterando o nosso contador.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Contador {
</span><span class="boring">    contagem: u64
</span><span class="boring">}
</span><span class="boring">impl Iterator for Contador {
</span><span class="boring">    type Item = u64;
</span><span class="boring">
</span><span class="boring">    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</span><span class="boring">        if self.contagem &gt;= 100 {
</span><span class="boring">            None
</span><span class="boring">        } else {
</span><span class="boring">            self.contagem += 1;
</span><span class="boring">            Some(self.contagem)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span>//--declaração do contador
fn main() {
    let mut contador = Contador { contagem: 0 };

    while let Some(n) = contador.next() {
        println!(&quot;Contador atual {}&quot;, n)
    }
}
</code></pre></pre>
<p>O enum <code>Option</code>, nos da um controle muito grande, e nos possibilita vários modos de tratar valores inexistentes, vale a pena se aprofundar mais nele.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="coleção-vec"><a class="header" href="#coleção-vec">Coleção Vec</a></h1>
<p>Em Rust já temos coleções implementadas, uma delas é a <code>Vec&lt;T&gt;</code>, é uma coleção que armazena uma quantidade de elementos. A vantagem de usar essa coleção é que diferente de um <a href="intermediary-02/../basic/09-arrays.html">array</a> é que seu tamanho é flexível. O que nos da certa vantagem. Podemos criar um <code>Vec</code> com os métodos estáticos <code>new</code> ou <code>with_capacity</code>, ou com o macro <code>vec!</code>, sendo a opção com o macro um <code>Vec</code> já inicializado com valores. Podemos declarar o <code>Vec</code></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut vec = Vec::&lt;i32&gt;::new();
    let mut vec2: Vec&lt;i32&gt; = Vec::new();
    let mut vec3 = Vec::&lt;i32&gt;::with_capacity(10); //inicia o Vec já com uma capacidade
    let mut vec4: Vec&lt;i32&gt; = Vec::with_capacity(10); //inicia o Vec já com uma capacidade
    let mut vec5 = vec![1,2,3];
}
</code></pre></pre>
<p>Iniciar um <code>Vec</code> já com uma capacidade o que nos da vantagem de deixar mais rápido a inserção de novos elementos nesse <code>Vec</code>, mas não vamos confundir a capacidade dele, com o tamanho dele, a capacidade é &quot;o quanto cabe&quot; e o tamanho é o &quot;o quanto tem&quot;.</p>
<p>Note que declaramos todos os <code>Vec</code> como mutáveis, não é obrigatório serem declarados como mutáveis, nós só utilizamos isso caso queiramos realizar qualquer modificação no <code>Vec</code>, como adicionar, ou remover valores do mesmo.</p>
<p>O compilador do Rust é inteligente o suficiente para saber o tipo de um <code>Vec</code> pelo primeiro elemento adicionado.</p>
<h2 id="métodos-de-vec"><a class="header" href="#métodos-de-vec">Métodos de Vec</a></h2>
<p>Em Vec temos diversos métodos, mas agora iremos falar sobre os seguintes métodos: push, pop, len, clear, is_empty, contains, get, get_mut, insert e remove.</p>
<h3 id="método-push"><a class="header" href="#método-push">Método push</a></h3>
<p>O método <code>push</code> é responsável por adicionar um elemento ao <code>Vec</code>, o método ira falhar caso a capacidade do <code>Vec</code> ultrapasse o valor máximo de um <code>isize</code></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut lista = Vec::new();
    lista.push(10);

    println!(&quot;{:?}&quot;, lista);
}
</code></pre></pre>
<h3 id="método-insert"><a class="header" href="#método-insert">Método insert</a></h3>
<p>Com o método insert conseguimos adicionar um valor na posição escolhida</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut lista = vec![1, 2, 3];
    lista.insert(0, 4);

    println!(&quot;{:?}&quot;, lista);
}
</code></pre></pre>
<h3 id="método-pop"><a class="header" href="#método-pop">Método pop</a></h3>
<p>O método <code>pop</code> remove o último elemento do <code>Vec</code> e nos retornar um <code>Option&lt;T&gt;</code>, sendo o <code>Some</code> caso tenha algum elemento e <code>None</code> caso o <code>Vec</code> esteja vazio.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut lista = vec![1, 2, 3];
    let ultimo: Option&lt;i32&gt; = lista.pop();

    println!(&quot;{:?}&quot;, lista);
}
</code></pre></pre>
<h3 id="método-len"><a class="header" href="#método-len">Método len</a></h3>
<p>O método <code>len</code> retorna o tamanho do <code>Vec</code></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let lista = vec![1,2,3];
    let tamanho = lista.len();

    println!(&quot;{}&quot;, tamanho);
}
</code></pre></pre>
<h3 id="método-get"><a class="header" href="#método-get">Método get</a></h3>
<p>O método <code>get</code> retorna um <code>Option&lt;&amp;T&gt;</code> caso a posição solicitada exista, caso não exista é retornado um <code>None</code>, a vantagem de utilizar este método ao invés de um colchete e a posição <code>[pos]</code> é que se tentarmos acessar uma posição inexistente não paramos a execução da aplicação.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let lista = vec![1,2,3];
    let primeiro_elemento: Option&lt;&amp;i32&gt; = lista.get(0);
    // let invalido = lista[1000]; //esta linha ira parar a execução do programa
}
</code></pre></pre>
<h3 id="método-get_mut"><a class="header" href="#método-get_mut">Método get_mut</a></h3>
<p>O método <code>get_mut</code>, tem um comportamento parecido com o do método <code>get</code> a principal diferença é que este método nos retorna uma referncia mutável, sendo assim, podemos alterar o valor contido no index. Para que este método possa ser executado, o <code>Vec</code> deve ser mutável</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut lista = vec![1, 2, 3];
    let r = lista.get_mut(0).unwrap();
    *r = 10;
    println!(&quot;{:?}&quot;, lista);
}
</code></pre></pre>
<h3 id="método-remove"><a class="header" href="#método-remove">Método remove</a></h3>
<p>Com o método remove, podemos remover um item do <code>Vec</code> informando a sua posição. Claro para isso o <code>Vec</code> deve ser mutável.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut lista = vec![1, 2, 3];
    lista.remove(0);
    println!(&quot;{:?}&quot;, lista);
}
</code></pre></pre>
<h3 id="método-clear"><a class="header" href="#método-clear">Método clear</a></h3>
<p>O método <code>clear</code> limpa o <code>Vec</code> o deixando vazio</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut lista = vec![1,2,3];
    lista.clear();
    println!(&quot;Tamanho da lista {}&quot;, lista.len());
}
</code></pre></pre>
<h3 id="método-is_empty"><a class="header" href="#método-is_empty">Método is_empty</a></h3>
<p>O método <code>is_empty</code> retorna um booleano, sendo true caso esteja vazio e false caso o tenha algum elemento</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let lista = Vec::&lt;i32&gt;::new();
    if lista.is_empty() {
        println!(&quot;A lista esta vazia&quot;);
    }
}
</code></pre></pre>
<h3 id="método-contains"><a class="header" href="#método-contains">Método contains</a></h3>
<p>O método <code>contains</code>retorna um booleano, sendo true caso o valor exista e false caso não exista.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let lista = vec![1, 2, 3];
    if lista.contains(&amp;3) {
        println!(&quot;O numero 3 existe na lista&quot;);
    }
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hashset"><a class="header" href="#hashset">HashSet</a></h1>
<p>O <code>HashSet</code> é uma das coleções da biblioteca padrão do Rust, esta biblioteca é parecida com o <a href="intermediary-02/./08-vec.html">Vec</a>, porém ela não permite repetições. Ela utiliza algum algorítimo de <a href="intermediary-02/./https://en.wikipedia.org/wiki/Hash_function">Hash</a> para garantir que os elementos inseridos serão únicos.</p>
<h2 id="usando-um-hashset"><a class="header" href="#usando-um-hashset">Usando um HashSet</a></h2>
<p>Um <code>HashSet</code> é uma coleção genérica, e assim como o ela armazena dados de vários tipo, porém para tais dados serem armazenados eles precisam implementar certas <a href="intermediary-02/./06-traits.html">traits</a>, para começar vamos utilizar os tipos primitivos.</p>
<h3 id="criando-um-hashset"><a class="header" href="#criando-um-hashset">Criando um HashSet</a></h3>
<p>Temos alguns modos para criar um <code>HashSet</code>.</p>
<p>Temos um modo declarando o tipo e instânciando que segue o padrão <code>let nome: HashSet&lt;tipo&gt; = HashSet::new()</code>, o modo por inferência, <code>let nome = HashSet::&lt;tipo&gt;::new()</code>, claro podemos fazer <code>let nome: HashSet&lt;tipo&gt; = HashSet::&lt;tipo&gt;::new()</code> ou <code>let nome = HashSet::new()</code> e o tipo é definido pelo primeiro uso.</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashSet;

fn main() {
    let mut hashSet: HashSet&lt;i32&gt; = HashSet::new();
    let mut hashSet2 = HashSet::&lt;i32&gt;::new();
    let mut hashSet3 = HashSet::new();
    hashSet3.insert(10);
}
</code></pre></pre>
<p><small>No exemplo acima só utilizamos <code>mut</code> para poder manipular o <code>HashSet</code></small><br><br>
Temos alguns métodos para trabalhar com um <code>HashSet</code>, como, por exemplo, <code>insert</code>, <code>contains</code>, <code>remove</code>, <code>get</code></p>
<h3 id="método-insert-1"><a class="header" href="#método-insert-1">Método insert</a></h3>
<p>O método <code>insert</code> funciona para inserirmos um elemento ao <code>HashSet</code>. Já o utilizamos no exemplo de criação de um <code>HashSet</code>, este método nos retorna um booleano com <code>true</code> caso consiga inserir com sucesso e false caso não consiga.</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashSet;

fn main() {
    let mut set = HashSet::new();
    if set.insert(10) {
        println!(&quot;Eitcha lele&quot;);
    }
    if !set.insert(10) {
        println!(&quot;Que coisa nao&quot;);
    }
}
</code></pre></pre>
<h3 id="método-contains-1"><a class="header" href="#método-contains-1">Método contains</a></h3>
<p>O método contains, serve para verificarmos se um elemento existe no <code>HashSet</code> nos retornando um <code>true</code> caso exista e <code>false</code> caso não.</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashSet;

fn main() {
    let mut set = HashSet::new();
    set.insert(10);
    if set.contains(&amp;10) {
        println!(&quot;EXISTEEEEEEEEEEEEEEEEEEEEE&quot;);
    }
}
</code></pre></pre>
<h3 id="método-remove-1"><a class="header" href="#método-remove-1">Método remove</a></h3>
<p>O método remove como o seu nome diz, remove um elemento da coleção. Nos retornando <code>true</code> caso consiga remover e <code>false</code> caso não.</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashSet;

fn main() {
    let mut set = HashSet::new();
    set.insert(10);
    if set.remove(&amp;10) {
        println!(&quot;Removido&quot;);
    }
}
</code></pre></pre>
<h3 id="método-get-1"><a class="header" href="#método-get-1">Método get</a></h3>
<p>O método get recupera um valor da coleção, nos retornando um <a href="intermediary-02/./07-option.html">Option</a>.</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashSet;

fn main() {
    let mut set = HashSet::new();
    set.insert(10);
    let num = set.get(&amp;10);
}
</code></pre></pre>
<p>Temos alguns métodos com funcionamentos iguais aos de um <a href="intermediary-02/./08-vec.html">Vec</a> como <code>is_empty</code>, <code>clear</code>, <code>len</code>.</p>
<h1 id="usando-um-hashset-com-um-tipo-nosso"><a class="header" href="#usando-um-hashset-com-um-tipo-nosso">Usando um HashSet com um &quot;tipo nosso&quot;</a></h1>
<p>Nem sempre é tão simples utilizar um <code>HashSet</code>, para tipos que criamos, como <a href="intermediary-02/./02-enums.html">enums</a> ou <a href="intermediary-02/./01-structs.html">structs</a>, como no exemplo abaixo:</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashSet;

struct Cliente {
    id: i32,
    nome: String
}

fn main() {
    let mut set = HashSet::&lt;Cliente&gt;::new();
    set.insert(Cliente { id: 10, nome: &quot;Rust4Noobs&quot;.to_string() });
}
</code></pre></pre>
<p>Ao tentarmos utilizar o método <code>insert</code> teremos um problema.</p>
<pre><code class="language-bash">error[E0599]: the method `insert` exists for struct `HashSet&lt;Cliente&gt;`, but its trait bounds were not satisfied
  --&gt; src/main.rs:10:9
   |
3  | struct Cliente {
   | --------------
   | |
   | doesn't satisfy `Cliente: Eq`
   | doesn't satisfy `Cliente: Hash`
...
10 |     set.insert(Cliente { id: 10, nome: &quot;Rust4Noobs&quot;.to_string() });
   |         ^^^^^^ method cannot be called on `HashSet&lt;Cliente&gt;` due to unsatisfied trait bounds
   |
   = note: the following trait bounds were not satisfied:
           `Cliente: Eq`
           `Cliente: Hash`

For more information about this error, try `rustc --explain E0599`.
error: could not compile `traits` due to previous error
</code></pre>
<p>Para utilizarmos um <code>HashSet</code> nossa struct precisa implementar duas traits, sendo elas <code>Eq</code> e <code>Hash</code>, porém para implementar <code>Eq</code> é necessário implementar <code>PartialEq</code>, essas traits podem ser geradas por macros como no exemplo abaixo.</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashSet;

#[derive(PartialEq, Eq, Hash)]
struct Cliente {
    id: i32,
    nome: String
}

fn main() {
    let mut set = HashSet::&lt;Cliente&gt;::new();
    set.insert(Cliente { id: 10, nome: &quot;Rust4Noobs&quot;.to_string() });
}
</code></pre></pre>
<p>Essas traits servem para comparação e geração do Hash, ou podemos também implementar por nós mesmos.</p>
<pre><pre class="playground"><code class="language-rust">use std::hash::Hash;
use std::collections::HashSet;

struct Cliente {
    id: i32,
    nome: String
}

impl PartialEq for Cliente {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        self.id == other.id //decidimos comparar apenas o id, ignorando o nome
    }
}

impl Hash for Cliente {
    fn hash&lt;H: std::hash::Hasher&gt;(&amp;self, state: &amp;mut H) {
        self.id.hash(state); //geramos o hash apenas com o id
    }
}

impl Eq for Cliente {}

fn main() {
    let mut set = HashSet::&lt;Cliente&gt;::new();
    set.insert(Cliente { id: 10, nome: &quot;Rust4Noob&quot;.to_string() });
}
</code></pre></pre>
<p>Agora podemos utilizar a nossa struct em um <code>HashSet</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hashmap"><a class="header" href="#hashmap">HashMap</a></h1>
<p>A última coleção que iremos falar é o <code>HashMap</code>, esta coleção funciona como um <a href="intermediary-02/./09-hashset.html">HashSet</a>, porém com o conceito de <a href="intermediary-02/./https://hazelcast.com/glossary/key-value-store/">chave-valor</a>, onde temos uma chave associada a um valor, esta chave <strong>NÃO</strong> se repete, assim como um valor em um <code>HashSet</code>, porém para inserirmos e recuperarmos valores, utilizamos a chave. Assim como no <code>HashSet</code>, essa chave deve implementar <code>Eq</code> e <code>Hash</code> e para implementar <code>Eq</code> é necessário implementar <code>PartialEq</code>.</p>
<h2 id="criando-um-hashmap"><a class="header" href="#criando-um-hashmap">Criando um HashMap</a></h2>
<p>Para criar um <code>HashMap</code>, precisamos informar dois tipos genéricos.</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let mut map1 = HashMap::&lt;String, i32&gt;::new();
    let mut map2: HashMap&lt;String, i32&gt; = HashMap::new();
    let mut map3 = HashMap::new();
    map3.insert(&quot;Rust4Noobs&quot;.to_string(), i32::MAX);
}
</code></pre></pre>
<p>Temos vários métodos para criar um <code>HashMap</code>, acima temos alguns exemplos. Os métodos que iremos falar serão, <code>insert</code>, <code>remove</code>, <code>get</code>, <code>get_mut</code>, <code>len</code>, <code>remove</code>, <code>clear</code>.</p>
<h3 id="método-insert-2"><a class="header" href="#método-insert-2">Método insert</a></h3>
<p>Para inserirmos uma chave e valor em um <code>HashMap</code> precisamos utilizar o método <code>insert</code> passando como argumentos uma <code>chave</code>e um <code>valor</code> este método nos retorna um <a href="intermediary-02/./07-option.html">Option</a>.</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(&quot;Rust4Noobs&quot;, i32::MAX);
}
</code></pre></pre>
<p>O método <code>insert</code> tem uma peculiaridade, ao inserir um valor e este valor ainda não existe, o <code>Option</code> retornado sera um <code>None</code> e o valor será inserido no <code>HashMap</code>, caso o valor já exista o <code>Option</code> retornado sera um <code>Some</code> com o valor antigo e este valor é substituído na coleção.</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    let inserido = map.insert(&quot;Rust4Noobs&quot;, i32::MAX);
    println!(&quot;{:?}&quot;, inserido);
    let inserido = map.insert(&quot;Rust4Noobs&quot;, i32::MIN);
    println!(&quot;{:?}&quot;, inserido);
}
</code></pre></pre>
<h3 id="método-get-2"><a class="header" href="#método-get-2">Método get</a></h3>
<p>O método <code>get</code> funciona de maneira parecida com o <code>Vec</code> e o <code>Set</code>, porém passamos uma chave e nos é devolvido um <code>Option</code>. Caso o valor exista temos um <code>Some</code> com o valor caso não temos um <code>None</code>.</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(&quot;Rust4Noobs&quot;, i32::MAX);
    let rust4_noobs = map.get(&quot;Rust4Noobs&quot;);
    let rust4_experts = map.get(&quot;Rust4Experts&quot;);

    println!(&quot;{:?}&quot;, rust4_noobs);
    println!(&quot;{:?}&quot;, rust4_experts);
}
</code></pre></pre>
<h3 id="método-get_mut-1"><a class="header" href="#método-get_mut-1">Método get_mut</a></h3>
<p>O método <code>get_mut</code> do mesmo modo que o método <code>get</code>, com a diferença de nos retornar uma referência mutável do valor e somente pode ser usado caso o <code>HashMap</code> seja mutável.</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

#[derive(PartialEq, Eq, Hash, Debug)]
struct Cliente {
    id: i32,
    nome: String
}

fn main() {
    let mut map = HashMap::new();
    map.insert(&quot;Rust4Noobs&quot;, Cliente { id: 0, nome: &quot;https://github.com/pgjbz/rust4noobs&quot;.to_string()});
    let rust4_noobs = map.get_mut(&quot;Rust4Noobs&quot;);
    println!(&quot;{:?}&quot;, rust4_noobs);
    if let Some(rust) = rust4_noobs {
        rust.nome = &quot;Nome Brabo&quot;.to_string();
    }
    let rust4_noobs = map.get_mut(&quot;Rust4Noobs&quot;);
    println!(&quot;{:?}&quot;, rust4_noobs);
}
</code></pre></pre>
<p><small>Sim, podemos redeclarar uma variável com um nome já existente e eu só mostrei isso agora, eu errei, eu sei</small></p>
<h3 id="método-len-1"><a class="header" href="#método-len-1">Método len</a></h3>
<p>O método <code>len</code> nos retorna o tamanho do <code>HashMap</code>.</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(&quot;Rust4Noobs&quot;, i32::MAX);
    let len = map.len();
    println!(&quot;len = {}&quot;, len);
}
</code></pre></pre>
<h3 id="método-remove-2"><a class="header" href="#método-remove-2">Método remove</a></h3>
<p>Utilizamos o método <code>remove</code> quando queremos remover alguma chave do nosso <code>HashMap</code>, nos retornando um <code>Option</code>, sendo <code>Some</code> contendo o valor removido, caso o valor exista e tenha sido removido e <code>None</code> caso o valor removido não exista.</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(&quot;Rust4Noobs&quot;, i32::MAX);
    let rust4_noobs = map.get(&quot;Rust4Noobs&quot;);
    println!(&quot;Rust4Noobs {:?}&quot;, rust4_noobs);
    let valor_removido = map.remove(&quot;Rust4Noobs&quot;);
    println!(&quot;Valor removido {:?}&quot;, valor_removido);
    let rust4_noobs = map.get(&quot;Rust4Noobs&quot;);
    println!(&quot;Rust4Noobs {:?}&quot;, rust4_noobs);
}
</code></pre></pre>
<h3 id="método-clear-1"><a class="header" href="#método-clear-1">Método clear</a></h3>
<p>O método <code>clear</code> é o mais simples dentre todos, este método apenas, limpa o nosso <code>HashSet</code>.</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(&quot;Rust4Noobs&quot;, i32::MAX);
    map.clear();
    println!(&quot;Tamanho do HashSet = {}&quot;, map.len());
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tratamento-de-erros"><a class="header" href="#tratamento-de-erros">Tratamento de erros</a></h1>
<p>Em Rust não temos exceções, não temos <code>nulos</code>, temos <a href="intermediary-02/./07-option.html">Option</a> e para tratar erros temos <code>Result&lt;T, E&gt;</code>, o tipo <code>Result</code> assim como o tipo <code>Option</code> é um <a href="intermediary-02/./02-enums.html">Enum</a>, contendo dois valores <code>Ok(T)</code> e <code>Err(E)</code>, sendo <code>Ok</code> o e <code>Err</code> quando tivermos uma falha.</p>
<p>Assim como <code>Option</code> o <code>Result</code> também tem alguns métodos. Iremos fazer algo um pouco diferente neste capítulo, ele sera mais prático, porém nada muito complexo.</p>
<p>Tendo o código abaixo.</p>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;

fn main() {
    let file = File::open(&quot;rust4noobs.txt&quot;);
}
</code></pre></pre>
<p>A variável file, esta recebendo um <code>Result&lt;File, std::io::Error&gt;</code>, podemos realizar apenas um <code>.unwrap()</code> para caso o arquivo não exista, ou não termos permissão para acesso, ou qualquer outro erro aconteça encerarmos a execução do programa, ou caso de sucesso prosseguirmos com a solução do problema. Mas não queremos fazer isso. Caso o tivermos algum erro, mais específico, o arquivo não existir, vamos criar este arquivo e escrever nele &quot;Rust4Noobs&quot;, caso qualquer um destes processos do tratamento falhe, iremos simplesmente encerrar o programa.</p>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;
use std::io::Write;
use std::process;

fn main() {
    let file = abre_arquivo(&quot;rust4noobs.txt&quot;);
}

fn abre_arquivo(caminho: &amp;str) -&gt; File {
    match File::open(caminho) {
        Ok(file) =&gt; file,
        Err(e) =&gt; match e.kind() {
            std::io::ErrorKind::NotFound =&gt; {
                let mut file = File::create(&quot;rust4noobs.txt&quot;).unwrap();
                file.write_all(b&quot;Rust4Noobs&quot;).unwrap();
                file
            },
            e =&gt; {
                eprintln!(&quot;Tivemos um probleminha aqui {:?}&quot;, e);
                process::exit(1)
            }
        }
    }
}
</code></pre></pre>
<p>No código acima, tentamos abrir o arquivo, caso tenhamos sucesso, retornamos o arquivo, caso aconteça algum erro executamos o procedimento de validar o tipo do erro, caso o erro seja do tipo &quot;NotFound&quot;, então criamos o arquivo e escrevemos nele, já dando <code>.unwrap</code> caso de algum erro, após isso já retornamos o arquivo, para ser utilizado. Caso o erro não seja do tipo <code>NotFound</code> apenas escrevemos o erro e finalizamos o processo.</p>
<p>Agora vamos eliminar esses <code>unwrap</code> com o operador <code>?</code>, para isso precisamos realizar algumas modificações.</p>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;
use std::io;
use std::io::Write;
use std::process;

fn main() -&gt; Result&lt;(), io::Error&gt; {
    let file = abre_arquivo(&quot;rust4noobs.txt&quot;)?;
    Ok(())
}

fn abre_arquivo(caminho: &amp;str) -&gt; Result&lt;File, io::Error&gt; {
    match File::open(caminho) {
        Ok(file) =&gt; Ok(file),
        Err(e) =&gt; match e.kind() {
            std::io::ErrorKind::NotFound =&gt; {
                let mut file = File::create(&quot;rust4noobs.txt&quot;)?;
                file.write_all(b&quot;Rust4Noobs&quot;)?;
                Ok(file)
            },
            e =&gt; {
                eprintln!(&quot;Tivemos um probleminha aqui {:?}&quot;, e);
                process::exit(1)
            }
        }
    }
}
</code></pre></pre>
<p>No nosso <code>main</code> adicionamos <code>-&gt; Result&lt;(), io::Error&gt;</code> e no fim retornamos  <code>Ok(())</code> no método <code>abre_arquivo</code> agora ao invés de retornarmos o arquivo diretamente, retornamos um <code>Result&lt;File, io::Error&gt;</code> e substituímos os <code>.unwrap()</code> por um <code>?</code>, o operador <code>?</code> realiza o processo de <code>unwrap</code> e caso não tenha sucesso ele propaga o erro para quem o chamou, por isso precisamos retornar um <code>Result</code>, quando chegamos no método <code>main</code>, não queremos tratar então só propagamos o erro.</p>
<h2 id="criando-nossos-próprios-erros"><a class="header" href="#criando-nossos-próprios-erros">Criando nossos próprios erros.</a></h2>
<p>Enquanto eu aprendo mais sobre Rust e escrevo este 4Noobs, eu estou aprendendo mais sobre interpretadores. Em alguns pontos código do meu interpretador eu preciso de <code>Result</code> ao invés de <code>Option</code>, isso quando é algo que pode falhar e ter tratativas diferentes dependendo do  erro. Por exemplo, no meu interpretador eu considero o fim do arquivo como um erro. Porém, não é um erro que para a execução do interpretador, é um erro que significa que não tenho mais tokens, então posso seguir para a próxima parte. Agora caso tenhamos um erro de sintaxe, salvamos isso em um erro para informar a quem estiver usando a linguagem.</p>
<p>Temos abaixo um exemplo simples desse caso.</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
enum ParseError {
    Eof,
    Inaceitavel(String)
}

impl std::error::Error for ParseError {}

impl std::fmt::Display for ParseError {
    //implementação do display
}

fn faz_o_parse_ai(mock: u8) -&gt; Result&lt;(), ParseError&gt; {

    if mock &gt;= 100 &amp;&amp; mock &lt;= 199 {
        return Err(ParseError::Inaceitavel(&quot;como assim vc me deu esse valor?&quot;.to_string()));
    } else if mock &gt; 200 {
        return Err(ParseError::Eof)
    }
    Ok(())
}

fn main() {
    let mut erros = Vec::new();
    match faz_o_parse_ai(35 + 34) {
        Ok(()) =&gt; {},
        Err(e) =&gt; match e {
            ParseError::Eof =&gt; {/* só continua para a próxima parte */},
            ParseError::Inaceitavel(msg) =&gt; erros.push(msg),
        }
    }
}
</code></pre></pre>
<p>O uso do meu próprio <code>Enum</code> e é algo que facilita a minha leitura, por saber que se trata especificamente de um erro de <code>Parse</code>, assim como as <code>exceções</code>em <code>Java</code> ou qualquer outra linguagem, use algo que faça sentido, não retorne um erro de parse o erro for sobre não conseguir vender maçãs.</p>
<p>Claro como <code>Result&lt;T, E&gt;</code> é um tipo genérico, não é obrigatório que o meu erro seja um <code>Enum</code> ou qualquer coisa, posso retornar um <code>i32</code>, <code>String</code>, qualquer coisa.</p>
<p>O único ponto que devemos ficar atentos é que caso implementemos a trait &quot;Error&quot; do pacote &quot;std::error&quot; precisamos também implementar a trait &quot;Debug&quot; e a trait &quot;Display&quot;, isso é util caso o nosso método retorne mais de um tipo de erro, no módulo avançado iremos ver como fazer isso.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macro-panic"><a class="header" href="#macro-panic">Macro panic!</a></h1>
<p>O macro <code>panic!</code> é utilizado quando queremos encerrar a execução de um programa com ou sem uma mensagem, quando utilizamos o <code>.unwrap</code> ou <code>.expect</code> em um <a href="intermediary-02/./02-enums.html">enum</a> <code>None</code> ou algum <a href="intermediary-02/./11-result.html">Result</a> com <code>Erro</code> basicamente o que acontece por trás dos panos ele executa a ação do <code>panic</code> encerrando a execução do programa, com ou sem uma mensagem, cabe ao programador decidir usar ou não esta feature.</p>
<h2 id="utilizando-o-macro-panic"><a class="header" href="#utilizando-o-macro-panic">Utilizando o macro panic!</a></h2>
<p>Para utilizar o macro seguimos os seguintes padrões <code>panic!()</code> ou <code>panic!(mensagem)</code></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    panic!();
}
</code></pre></pre>
<p>Ao executar o código acima temos a saída</p>
<pre><code class="language-bash">thread 'main' panicked at 'explicit panic', src/main.rs:2:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrac
</code></pre>
<p>Ou executando o código abaixo</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    panic!(&quot;Rust4Noobs&quot;);
}
</code></pre></pre>
<p>Temos a saída com a mensagem abaixo:</p>
<pre><code class="language-bash">thread 'main' panicked at 'Rust4Noobs', src/main.rs:2:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testes"><a class="header" href="#testes">Testes</a></h1>
<p>Em Rust temos macros para testarmos nossas features, como os macros para &quot;<a href="https://en.wikipedia.org/wiki/Assertion">assertions</a>&quot; sendo eles <code>assert!</code>, <code>assert_eq!</code> e <code>assert_ne!</code>. Podemos utiliza-los em nosso código para testar as nossas funcionalidades, utilizando a ideia de <a href="intermediary-02/./04-modules.html">módulos</a> podemos criar um módulo especifico para os testes. E para isso utilizamos a opção de compilação <code>#[cfg(test)]</code>, esta configuração irá definir que é um módulo para testes e nesse módulo nós adicionamos nossos códigos de testes, e para informar que são testes utilizamos outro macro <code>#[test]</code>.
Este módulo de testes NÃO é compilado em nosso executável final.</p>
<p>Abaixo temos um exemplo da declaração de um módulo de testes já contendo dois testes, utilizando os macros <code>assert!</code>, <code>assert_eq!</code> e <code>assert_ne!</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {

    #[test]
    fn deve_ser_verdadeiro() {
        let maior = 1 &gt; 0;
        assert!(maior)
    }

    #[test]
    fn devem_ser_iguais() {
        assert_eq!(2 + 2, 4)
    }

    #[test]
    fn devem_ser_diferentes() {
        assert_ne!(1 + 1, 10)
    }

}
<span class="boring">}
</span></code></pre></pre>
<p>Com apenas esses 3 macros de <code>assert</code>, conseguimos testar muitas coisas, vamos a um exemplo mais complexo.</p>
<p>Temos um cliente que deseja fazer a integração de pagamentos com outro serviço e antes de enviar a requisição para realizar a integração, deve ser feito algumas validações, sendo elas:</p>
<ul>
<li>O valor a ser pago deve ser maior que 0.0</li>
<li>O valor a ser pago deve ser menor ou igual a 1000.0</li>
</ul>
<p>Vamos começar a escrever os nossos testes, antes de escrevemos nosso código.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod integracao_de_pagamento {

    pub fn valor_eh_valido(valor: f64) -&gt; bool {
        todo!()
    }

}

#[cfg(test)]
mod tests {

    use super::integracao_de_pagamento;

    #[test]
    fn valida_valor_pagamento_acima_de_dez_deve_retornar_verdadeiro() {
        let valor_valido = integracao_de_pagamento::valor_eh_valido(10.0);
        assert!(valor_valido);
    }

    #[test]
    fn valida_valor_pagamento_abaixo_de_zero_deve_retornar_falso() {
        let valor_valido = integracao_de_pagamento::valor_eh_valido(-10.0);
        assert!(!valor_valido);
    }

    #[test]
    fn valida_valor_pagamento_acima_de_mil_deve_retornar_falso() {
        let valor_valido = integracao_de_pagamento::valor_eh_valido(1001.0);
        assert!(!valor_valido)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>NOTA: Como <code>tests</code>é um módulo ele deve importar os outros módulos
NOTA 2: O nome do módulo não necessariamente deve ser &quot;tests&quot;</p>
<p>Para executar o código acima, devemos usar o comando <code>cargo test</code>, este comando ira executar todos os testes do projeto. Como esperado todos os testes vão falhar! Vamos escrever o nosso código.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod integracao_de_pagamento {

    pub fn valor_eh_valido(value: f64) -&gt; bool {
        valor &gt; 0.0
    }

}
<span class="boring">}
</span></code></pre></pre>
<p>Ao executar o comando <code>cargo test</code> temos a seguinte saída:</p>
<pre><code class="language-bash">running 3 tests
test tests::valida_valor_pagamento_acima_de_dez_deve_retornar_verdadeiro ... ok
test tests::valida_valor_pagamento_abaixo_de_zero_deve_retornar_falso ... ok
test tests::valida_valor_pagamento_acima_de_mil_deve_retornar_falso ... FAILED

failures:

---- tests::valida_valor_pagamento_acima_de_mil_deve_retornar_falso stdout ----
thread 'tests::valida_valor_pagamento_acima_de_mil_deve_retornar_falso' panicked at 'assertion failed: !valor_valido', src/lib.rs:29:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::valida_valor_pagamento_acima_de_mil_deve_retornar_falso

test result: FAILED. 2 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>Dois testes passaram e um teste falhou, pelas regras, devemos validar se o valor é menor ou igual a 1000.00 para ser valido.
Vamos alterar a implementação.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod integracao_de_pagamento {

    pub fn valor_eh_valido(value: f64) -&gt; bool {
        valor &gt; 0.0 &amp;&amp; valor &lt;= 1000.0
    }

}
<span class="boring">}
</span></code></pre></pre>
<p>E agora temos todos os testes funcionando.</p>
<pre><code class="language-bash">    Finished test [unoptimized + debuginfo] target(s) in 0.37s
     Running unittests (target/debug/deps/testes-83f2e46ed2822f78)

running 3 tests
test tests::valida_valor_pagamento_acima_de_mil_deve_retornar_falso ... ok
test tests::valida_valor_pagamento_acima_de_dez_deve_retornar_verdadeiro ... ok
test tests::valida_valor_pagamento_abaixo_de_zero_deve_retornar_falso ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests testes

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>Usamos apenas uma opção de <code>assert</code>, vamos utilizar outro teste.</p>
<p>Vamos usar aquela conta que todo mundo ama fazer no ensino médio, encontrar os valores de uma equação de segundo grau, e para isso usaremos a <a href="https://www.infoescola.com/matematica/formula-de-bhaskara/">Fórmula de Bhaskara</a> e também iremos aproveitar para explicar outro conceito que é quando um teste deve causar um <code>panic</code>.</p>
<p>Vamos às regras da Fórmula de Bhaskara:</p>
<ul>
<li>Para calcular Delta usaremos a fórmula <code>b²-4*a*c</code></li>
<li>Delta não pode ser negativo</li>
<li>Precisamos ter três valores (a, b e c)</li>
<li>Temos que devolver duas raízes</li>
<li>Para calcular as raízes usaremos (-b +- √delta) / 2*a</li>
</ul>
<p>Vamos escrever nossos testes:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod calculadora {

    pub fn calcular(a: f64, b: f64, c: f64) -&gt; Result&lt;(f64, f64), String&gt; {
        todo!()
    }

    pub(super) fn calcula_delta(a: f64, b: f64, c: f64) -&gt; Result&lt;f64, String&gt; {
        todo!()
    }

}

#[cfg(test)]
mod tests {

    use super::calculadora;


    #[test]
    #[should_panic]
    fn calcular_delta_negativo_esperado_error() {
        calculadora::calcula_delta(1.0, 2.0, 3.0).unwrap();
    }

    #[test]
    fn calcular_delta_nao_deve_haver_erro() {
        let delta = calculadora::calcula_delta(8.0, 7.0, -2.0).unwrap();
        assert_eq!(113.0, delta, &quot;o valor de desta esta errado&quot;)
    }

    #[test]
    fn deve_calcular_as_duas_raizes() {
        let resultado = calculadora::calcular(1.0, 3.0, -2.0).unwrap();
        assert_eq!((0.5615528128088303, -3.5615528128088303), resultado);
    }

    #[test]
    #[should_panic(expected = &quot;nao contem raiz real&quot;)]
    fn calcular_raizes_com_delta_negativo_esperado_error() {
        calculadora::calcular(1.0, 2.0, 3.0).unwrap();
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Ao executar o comando para os testes, teremos um teste que ira passar, que é o teste <code>calcular_delta_negativo_esperado_error</code>, isso acontece porque ele tem que causar um <code>panic</code>e o macro <code>todo!</code> causa o panic, porém não é o que queremos, então no último testes colocamos a mensagem que esperamos no <code>panic!</code>, que é &quot;nao contem raiz real&quot;.</p>
<p>Vamos seguir com a implementação do nosso cálculo.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod calculadora {

    pub fn calcular(a: f64, b: f64, c: f64) -&gt; Result&lt;(f64, f64), String&gt; {
        todo!()
    }

    pub(super) fn calcula_delta(a: f64, b: f64, c: f64) -&gt; Result&lt;f64, String&gt; {
        let delta = (b * b) - 4.0 * a * c;
        if delta &lt; 0.0 {
            return Err(&quot;nao contem raiz real&quot;.to_string())
        }
        Ok(delta)
    }

}
<span class="boring">}
</span></code></pre></pre>
<p>Agora temos dois testes que passam e dois testes que falham. Veja a saída no console:</p>
<pre><code class="language-bash">    Finished test [unoptimized + debuginfo] target(s) in 0.38s
     Running unittests (target/debug/deps/testes-83f2e46ed2822f78)

running 4 tests
test tests::calcular_delta_nao_deve_haver_erro ... ok
test tests::calcular_raizes_com_delta_negativo_esperado_error - should panic ... FAILED
test tests::calcular_delta_negativo_esperado_error - should panic ... ok
test tests::deve_calcular_as_duas_raizes ... FAILED

failures:

---- tests::calcular_raizes_com_delta_negativo_esperado_error stdout ----
thread 'tests::calcular_raizes_com_delta_negativo_esperado_error' panicked at 'not yet implemented', src/lib.rs:4:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
note: panic did not contain expected string
      panic message: `&quot;not yet implemented&quot;`,
 expected substring: `&quot;nao contem raiz real&quot;`
---- tests::deve_calcular_as_duas_raizes stdout ----
thread 'tests::deve_calcular_as_duas_raizes' panicked at 'not yet implemented', src/lib.rs:4:9


failures:
    tests::calcular_raizes_com_delta_negativo_esperado_error
    tests::deve_calcular_as_duas_raizes

test result: FAILED. 2 passed; 2 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>Como esperado aquele método que esta esperando uma mensagem especifica do panic, continua falhando. Vamos implementa-lo.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod calculadora {

    pub fn calcular(a: f64, b: f64, c: f64) -&gt; Result&lt;(f64, f64), String&gt; {
        let delta = calcula_delta(a, b, c)?;
        let menos_b = -b;
        let x1 = (menos_b + delta.sqrt()) / 2.0 * a;
        let x2 = (menos_b - delta.sqrt()) / 2.0 * a;
        Ok((x1, x2))
    }
<span class="boring">    pub(super) fn calcula_delta(a: f64, b: f64, c: f64) -&gt; Result&lt;f64, String&gt; {
</span><span class="boring">        let delta = (b * b) - 4.0 * a * c;
</span><span class="boring">        if delta &lt; 0.0 {
</span><span class="boring">            return Err(&quot;nao contem raiz real&quot;.to_string())
</span><span class="boring">        }
</span><span class="boring">        Ok(delta)
</span><span class="boring">    }
</span>}
<span class="boring">}
</span></code></pre></pre>
<p>Agora ao executar os testes teremos sucesso:</p>
<pre><code class="language-bash">    Finished test [unoptimized + debuginfo] target(s) in 0.32s
     Running unittests (target/debug/deps/testes-83f2e46ed2822f78)

running 4 tests
test tests::calcular_delta_nao_deve_haver_erro ... ok
test tests::calcular_delta_negativo_esperado_error - should panic ... ok
test tests::deve_calcular_as_duas_raizes ... ok
test tests::calcular_raizes_com_delta_negativo_esperado_error - should panic ... ok

test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests testes

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="snake-game"><a class="header" href="#snake-game">Snake Game</a></h1>
<p>Eu estava em dúvida em que projeto fazer neste ponto, foi difícil pensar em algo e, porque não  algo que eu nunca fiz?</p>
<p>Então vamos lá fazer o &quot;jogo da cobrinha&quot;, vamos começar criando o projeto, usando o comando <code>cargo new snake-game</code>.</p>
<p>Teremos a estrutura padrão do projeto:</p>
<pre><code class="language-bash">├── Cargo.toml
└── src
    └── main.rs
</code></pre>
<p>Vamos adicionar um arquivo chamado <code>lib.rs</code> na pasta <code>src</code>, este arquivo sera usado para declarar os nossos módulos. Em seguida criamos um arquivo chamado &quot;ponto.rs&quot; e nele iremos criar uma <a href="intermediary-02/./01-structs.html">struct</a> para as localizações no nosso jogo, vamos criar uma implementação a essa struct para facilitar a instânciação dessa <code>strutc</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Ponto {
    pub x: usize,
    pub y: usize
}

impl Ponto {
    pub fn new(x: usize, y: usize) -&gt; Self {
        Self {
            x,
            y
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Para que este arquivo seja reconhecido no projeto, vamos adicionar no nosso arquivo <code>lib.rs</code> a seguinte linha <code>pub mod point;</code>. Note que tanto a <code>struct</code> quanto seus atributos e a implementação do método <code>new</code> estão com a palavra <code>pub</code>, que faz eles serem visíveis fora desse módulo.</p>
<p>Vamos printar o campo onde a cobrinha ira andar, e para testar vamos adicionar um ponto nesse tabuleiro.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let ponto = Ponto::new(7, 7);
    let (x, y) = (15, 15);
    for x in 0..x {
        for y in 0..y {
            if ponto == (x, y) {
                print!(&quot;# &quot;)
            }  else {
                print!(&quot;- &quot;);   
            }
        }
        println!();
    }
}

</code></pre></pre>
<p>Note que comparamos a nossa <code>struct</code> Ponto, com uma tupla de (x, y), para isso ser possível, precisamos implementar uma <a href="intermediary-02/./06-traits.html">trait</a> chamada <a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html">PartialEq</a> a implementação para isso é relativamente simples. A <code>trait</code> recebe um parâmetro <a href="intermediary-02/./05-generics.html">genérico</a> na implementação vamos falar que esse parâmetro genérico é uma <code>tupla (usize, usize)</code>. E a partir dai implementamos nossa comparação.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl PartialEq&lt;(usize, usize)&gt; for Ponto {
    fn eq(&amp;self, other: &amp;(usize, usize)) -&gt; bool {
        self.x == other.0 &amp;&amp; self.y == other.1
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora quando rodarmos o projeto com <code>cargo run</code>, teremos um tabuleiro no console com um ponto na posição (7, 7).</p>
<pre><code class="language-bash">   Compiling snake-game v0.1.0 (/home/paulo.bezerra/workspace/ws-rust/rust4noobs/projects/snake-game)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/snake-game`
- - - - - - - - - - - - - - - 
- - - - - - - - - - - - - - - 
- - - - - - - - - - - - - - - 
- - - - - - - - - - - - - - - 
- - - - - - - - - - - - - - - 
- - - - - - - - - - - - - - - 
- - - - - - - - - - - - - - - 
- - - - - - - # - - - - - - - 
- - - - - - - - - - - - - - - 
- - - - - - - - - - - - - - - 
- - - - - - - - - - - - - - - 
- - - - - - - - - - - - - - - 
- - - - - - - - - - - - - - - 
- - - - - - - - - - - - - - - 
- - - - - - - - - - - - - - -
</code></pre>
<p>Agora vamos criar a <code>struct</code> da nossa cobrinha, para isso vamos adicionar a cabeça - que é um ponto - e uma lista de pontos para o corpo. Criamos o arquivo &quot;cobra.rs&quot; e adicionamos o <code>pub mod cobra</code> no arquivo <code>lib.rs</code>, e no arquivo &quot;cobra.rs&quot; adicionamos a struct.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Cobra {
    pub cabeca: Ponto,
    pub corpo: Vec&lt;Ponto&gt;,
}

impl Default for Cobra {
    fn default() -&gt; Self {
        Self { 
            cabeca: Ponto::new(7, 7), 
            corpo: vec![Ponto::new(6,7), Ponto::new(5,7)]
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>A implementação da <code>trait</code> <a href="https://doc.rust-lang.org/std/default/trait.Default.html">default</a> serve para termos um valor padrão para a <code>struct</code>. Vamos separar a nossa função de desenhar o tabuleiro e vamos passar uma referência para a <code>struct</code> da <code>cobra</code>, então com base nos dados passados ali vamos desenhar a nossa cobra.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_board(cobra: &amp;Cobra) {
    let (x, y) = (15, 15);
    for y in 0..y {
        for x in 0..x {
            if cobra.cabeca == (x, y) {
                print!(&quot;0 &quot;)
            } else if cobra.corpo.contains(&amp;Ponto::new(x, y)) {
                print!(&quot;# &quot;);   
            } else {
                print!(&quot;- &quot;);   
            }
        }
        println!();
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Temos a função e agora é só chamar ela na nossa função <code>main</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    print_board(&amp;Cobra::default())
}
</code></pre></pre>
<p>Após executar o comando <code>cargo run</code> temos o output:</p>
<pre><code class="language-bash">    Finished dev [unoptimized + debuginfo] target(s) in 0.00s
     Running `target/debug/snake-game`
- - - - - - - - - - - - - - - 
- - - - - - - - - - - - - - - 
- - - - - - - - - - - - - - - 
- - - - - - - - - - - - - - - 
- - - - - - - - - - - - - - - 
- - - - - - - - - - - - - - - 
- - - - - - - - - - - - - - - 
- - - - - # # 0 - - - - - - - 
- - - - - - - - - - - - - - - 
- - - - - - - - - - - - - - - 
- - - - - - - - - - - - - - - 
- - - - - - - - - - - - - - - 
- - - - - - - - - - - - - - - 
- - - - - - - - - - - - - - - 
- - - - - - - - - - - - - - - 
</code></pre>
<p>Agora temos a cabeça e o corpo, precismos começar a definir uma direção que a cobra irá seguir e movimentar o corpo da cobra.</p>
<p>Para isso criamos um enumarado de direções, seguimos o mesmo passo a passo, criamos um arquivo &quot;direcao.rs&quot; e adicionamos no arquivo <code>lib.rs</code> a declaração do módulo <code>pub mob direcao</code>.</p>
<p>Então adicionamos as 4 direções possíveis ao nosso enum.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Copy)]
pub enum Direcao {
    Cima,
    Baixo,
    Direita,
    Esquerda,
}

impl Default for Direcao {
    fn default() -&gt; Self {
        Self::Direita
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Criamos o enum já implementando a <code>trait default</code> para nos auxiliar, como o padrão de início da cobra sempre vai ser para a direita, colocamos o retorno do método o valor <code>Self::Direita</code>. Já derivamos as <code>traits</code>, <code>Clone</code> e <code>Copy</code> para não precisar passar esse enum como referência todas às vezes.</p>
<p>Agora na nossa <code>struct</code> da cobra, vamos adicionar o atributo da direção.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Cobra {
    pub cabeca: Ponto,
    pub corpo: Vec&lt;Ponto&gt;,
    direcao: Direcao
}

impl Default for Cobra {
    fn default() -&gt; Self {
        Self { 
            cabeca: Ponto::new(7, 7), 
            corpo: vec![Ponto::new(6,7), Ponto::new(5,7)],
            direcao: Default::default() 
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora temos um modo de saber para qual direção a cobra está andando.</p>
<p>Na nossa <code>struct Ponto</code> vamos adicionar a função para alterar o valor do ponto.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>impl Point {
   ...

    pub fn alterar(&amp;mut self, direcao: Direcao) {
        match Direcao {
            Direcao::Right =&gt; self.x += 1,
            Direcao::Left =&gt; self.x -= 1,
            Direcao::Up =&gt; self.y -= 1,
            Direcao::Down =&gt; self.y += 1,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Vamos aproveitar e adicionar testes unitários para o método de alterar:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod ponto_tests {
    use super::*;

    #[test]
    fn alterar_para_cima() {
        let mut ponto = Ponto::new(1, 1);
        ponto.alterar(Direcao::Cima);
        assert_eq!(Ponto::new(1, 0), ponto);
    }

    #[test]
    fn alterar_para_baixo() {
        let mut ponto = Ponto::new(1, 1);
        ponto.alterar(Direcao::Baixo);
        assert_eq!(Ponto::new(1, 2), ponto);
    }
    
    #[test]
    fn alterar_para_direita() {
        let mut ponto = Ponto::new(1, 1);
        ponto.alterar(Direcao::Direita);
        assert_eq!(Ponto::new(2, 1), ponto);
    }


    #[test]
    fn alterar_para_esquerda() {
        let mut ponto = Ponto::new(1, 1);
        ponto.alterar(Direcao::Esquerda);
        assert_eq!(Ponto::new(0, 1), ponto);
    }

}
<span class="boring">}
</span></code></pre></pre>
<p>Agora iremos adicionar a lógica para a cobra se mover, precisaremos de um método para mover a cabeça que é quem vai definir se o movimento é valido, se vai bater na parede, se vamos alterar a direção e já vamos adicionar os testes que consiste em, encerrar o jogo caso bata na parede, validar a posição dos pontos após algum movimento, etc.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Cobra {
    pub fn passo(&amp;mut self, tabuleiro: (usize, usize)) -&gt; Result&lt;(), &amp;'static str&gt; {
        let posicao_anterior_cabeca = self.cabeca;
        self.mover_cabeca(&amp;tabuleiro)?;
        self.mover_corpo(posicao_anterior_cabeca);
        Ok(())
    }

    pub fn alterar_direcao(&amp;mut self, direcao: Direcao) {
        self.direcao = direcao;
    }

    fn mover_cabeca(&amp;mut self, board: &amp;(usize, usize)) -&gt; Result&lt;(), &amp;'static str&gt; {
        match self.direcao {
            Direcao::Cima if self.cabeca.y == 0 =&gt; Err(&quot;fim de jogo, esbarrou na parede de cima&quot;),
            Direcao::Baixo if self.cabeca.y &gt;= board.1 =&gt; Err(&quot;fim de jogo, esbarrou na parede de baixo&quot;),
            Direcao::Esquerda if self.cabeca.x == 0 =&gt; Err(&quot;fim de jogo, esbarrou na parede da esquerda&quot;),
            Direcao::Direita if self.cabeca.x &gt;= board.0 =&gt; Err(&quot;fim de jogo, esbarrou na parede da direita&quot;),
            _ =&gt; {
                self.cabeca.alterar(self.direcao);
                Ok(())
            }
        }
    }

    fn mover_corpo(&amp;mut self, posicao_anterior_cabeca: Ponto) {
        let corpo = &amp;mut self.corpo;
        let mut posicao_anterior = posicao_anterior_cabeca;
        for ponto in corpo.iter_mut() {
            std::mem::swap(&amp;mut posicao_anterior, ponto);
        }
    }
}

...

#[cfg(test)]
mod cobra_tests {

    use super::*;

    #[test]
    fn mover_cabeca_cobra_para_direita_no_tabuleiro_deve_mover_com_sucesso() {
        let mut cobra = Cobra {
            cabeca: Ponto::new(7, 7),
            corpo: vec![],
            direcao: Direcao::Right,
        };
        let expected_point = Ponto::new(8, 7);
        cobra.mover_cabeca(&amp;(8, 8)).unwrap();
        assert_eq!(expected_point, cobra.cabeca);
    }

    #[test]
    fn mover_cabeca_cobra_para_esquerda_no_tabuleiro_deve_mover_com_sucesso() {
        let mut cobra = Cobra {
            cabeca: Ponto::new(7, 7),
            corpo: vec![],
            direcao: Direcao::Left,
        };
        let expected_point = Ponto::new(6, 7);
        cobra.mover_cabeca(&amp;(8, 8)).unwrap();
        assert_eq!(expected_point, cobra.cabeca);
    }

    #[test]
    fn mover_cabeca_cobra_para_cima_no_tabuleiro_deve_mover_com_sucesso() {
        let mut cobra = Cobra {
            cabeca: Ponto::new(7, 7),
            corpo: vec![],
            direcao: Direcao::Up,
        };
        let expected_point = Ponto::new(7, 6);
        cobra.mover_cabeca(&amp;(8, 8)).unwrap();
        assert_eq!(expected_point, cobra.cabeca);
    }

    #[test]
    fn mover_cabeca_cobra_para_baixo_no_tabuleiro_deve_mover_com_sucesso() {
        let mut cobra = Cobra {
            cabeca: Ponto::new(7, 7),
            corpo: vec![],
            direcao: Direcao::Down,
        };
        let expected_point = Ponto::new(7, 8);
        cobra.mover_cabeca(&amp;(8, 8)).unwrap();
        assert_eq!(expected_point, cobra.cabeca);
    }

    #[test]
    #[should_panic(expected = &quot;fim de jogo, esbarrou na parede da direita&quot;)]
    fn mover_cabeca_cobra_para_direita_no_tabuleiro_deve_esbarrar_na_parede() {
        let mut cobra = Cobra {
            cabeca: Ponto::new(7, 7),
            corpo: vec![],
            direcao: Direcao::Right,
        };
        cobra.mover_cabeca(&amp;(7, 7)).unwrap();
    }

    #[test]
    #[should_panic(expected = &quot;fim de jogo, esbarrou na parede da esquerda&quot;)]
    fn mover_cabeca_cobra_para_esquerda_no_tabuleiro_deve_esbarrar_na_parede() {
        let mut cobra = Cobra {
            cabeca: Ponto::new(0, 7),
            corpo: vec![],
            direcao: Direcao::Left,
        };
        cobra.mover_cabeca(&amp;(7, 7)).unwrap();
    }

    #[test]
    #[should_panic(expected = &quot;fim de jogo, esbarrou na parede de baixo&quot;)]
    fn mover_cabeca_cobra_para_baixo_no_tabuleiro_deve_esbarrar_na_parede() {
        let mut cobra = Cobra {
            cabeca: Ponto::new(0, 7),
            corpo: vec![],
            direcao: Direcao::Down,
        };
        cobra.mover_cabeca(&amp;(7, 7)).unwrap();
    }

    #[test]
    #[should_panic(expected = &quot;fim de jogo, esbarrou na parede de cima&quot;)]
    fn mover_cabeca_cobra_para_cima_no_tabuleiro_deve_esbarrar_na_parede() {
        let mut cobra = Cobra {
            cabeca: Ponto::new(0, 0),
            corpo: vec![],
            direcao: Direcao::Up,
        };
        cobra.mover_cabeca(&amp;(7, 7)).unwrap();
    }

    #[test]
    fn mover_cobra_inteira_para_a_direita_deve_mover() {
        let tabuleiro = (15, 15);
        let mut cobra = Cobra {
            cabeca: Ponto::new(7, 7),
            corpo: vec![Ponto::new(6, 7)],
            direcao: Direcao::Right,
        };
        cobra.passo(board).unwrap();
        assert_eq!(Ponto::new(8, 7), cobra.cabeca);
        assert_eq!(Ponto::new(7, 7), *cobra.corpo.first().unwrap());
    }

    #[test]
    fn mover_cobra_inteira_para_a_esquerda_deve_mover() {
        let tabuleiro = (15, 15);
        let mut cobra = Cobra {
            cabeca: Ponto::new(7, 7),
            corpo: vec![Ponto::new(6, 7)],
            direcao: Direcao::Left,
        };
        cobra.passo(board).unwrap();
        assert_eq!(Ponto::new(6, 7), cobra.cabeca);
        assert_eq!(Ponto::new(7, 7), *cobra.corpo.first().unwrap());
    }

    #[test]
    fn mover_cobra_inteira_para_cima_deve_mover() {
        let tabuleiro = (15, 15);
        let mut cobra = Cobra {
            cabeca: Ponto::new(7, 7),
            corpo: vec![Ponto::new(6, 7)],
            direcao: Direcao::Up,
        };
        cobra.passo(board).unwrap();
        assert_eq!(Ponto::new(7, 6), cobra.cabeca);
        assert_eq!(Ponto::new(7, 7), *cobra.corpo.first().unwrap());
    }

    #[test]
    fn mover_cobra_inteira_para_baixo_deve_mover() {
        let tabuleiro = (15, 15);
        let mut cobra = Cobra {
            cabeca: Ponto::new(7, 7),
            corpo: vec![Ponto::new(6, 7)],
            direcao: Direcao::Down,
        };
        cobra.passo(board).unwrap();
        assert_eq!(Ponto::new(7, 8), cobra.cabeca);
        assert_eq!(Ponto::new(7, 7), *cobra.corpo.first().unwrap());
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Notem o método de mover a cabeça da cobra:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn mover_cabeca(&amp;mut self, board: &amp;(usize, usize)) -&gt; Result&lt;(), &amp;'static str&gt; {
    match self.direcao {
        Direcao::Cima if self.cabeca.y == 0 =&gt; Err(&quot;fim de jogo, esbarrou na parede de cima&quot;),
        Direcao::Baixo if self.cabeca.y &gt;= board.1 =&gt; Err(&quot;fim de jogo, esbarrou na parede de baixo&quot;),
        Direcao::Esquerda if self.cabeca.x == 0 =&gt; Err(&quot;fim de jogo, esbarrou na parede da esquerda&quot;),
        Direcao::Direita if self.cabeca.x &gt;= board.0 =&gt; Err(&quot;fim de jogo, esbarrou na parede da direita&quot;),
        _ =&gt; {
            self.cabeca.alterar(self.direcao);
            Ok(())
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Temos nessa implementação o uso de um <code>if</code> que segue o valor do <a href="intermediary-02/./02-enums.html">enum</a>, afinal o que é isso?</p>
<p>Isso faz parte do <a href="intermediary-02/./03-match.html">Pattern Match</a>, é algo que chamamos de <a href="https://doc.rust-lang.org/rust-by-example/flow_control/match/guard.html">guards</a>, do modo em que essa implementação é feita, temos duas validações para cair nesse ponto, o <code>enum</code> deve bater ali e a condição deve ser verdadeira, caso uma das duas condições falhe ele segue para o próximo <code>match</code>.</p>
<p>Na função de mover o corpo temos a lógica para mover o restante da cobra, guardamos a posição do ponto antes de ser alterada e fazemos o próximo item a ser iterado a obter essa posição. Para isso usamos o método da biblioteca padrão do Rust, <code>swap</code>, esse método troca o valor de duas referências que são passadas.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn mover_corpo(&amp;mut self, posicao_anterior_cabeca: Ponto) {
    let corpo = &amp;mut self.corpo;
    let mut posicao_anterior = posicao_anterior_cabeca;
    for ponto in corpo.iter_mut() {
        std::mem::swap(&amp;mut posicao_anterior, ponto);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora temos a lógica de mover a cobra, mas temos um problema nela, no método de alterar a direção, não temos uma validação para saber se o jogador, selecionou a opção de direção contraria da que a cobra esta seguindo, vamos adicionar agora.</p>
<p>No nosso enum de direção, vamos adicionar um método para pegar a direção contraria.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Direcao {
    pub fn direcao_inversa(outro: Self) -&gt; Self {
        match outro {
            Self::Cima =&gt; Self::Baixo,
            Self::Baixo =&gt; Self::Cima,
            Self::Direita =&gt; Self::Esquerda,
            Self::Esquerda =&gt; Self::Direita
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Deixo o teste deste método por sua conta.</p>
<p>E agora no nosso método de alterar a direção, faremos a validação, também deixo por sua conta esta alteração, e os testes da mesma.</p>
<p>Agora que temos o tabuleiro do jogo sendo desenhado, e temos a movimentação da cobra programada, vamos adicionar o petisco que iremos ter que pegar no jogo. O petisco é um ponto, então não precisamos criar outra <code>struct</code> para ela, apenas vamos gerar um ponto aleatório e fazer o nosso render renderiza-lo.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn gerar_petisco(cobra: &amp;Cobra, tabuleiro: &amp;(usize, usize)) -&gt; Point {
    let mut petisco;
    loop {
        let x = rand::thread_rng().gen_range(0..=tabuleiro.0 - 1);
        let y = rand::thread_rng().gen_range(0..=tabuleiro.1 - 1);
        petisco = Point::new(x, y);
        if cobra.cabeca != petisco &amp;&amp; !cobra.corpo.contains(&amp;petisco) {
            break;
        }
    }
    petisco
}
<span class="boring">}
</span></code></pre></pre>
<p>Para esse <a href="https://crates.io/crates/rand">rand</a> funcionar precisamos ir em nosso Cargo.toml e adicionar a seguinte dependência <code>rand = &quot;0.8.5&quot;</code> logo abaixo do <code>[dependencies]</code>, nesse método temos validações para não gerar um petisco em cima da cobra, ou seja, se o valor aleatório cair na cabeça ou em alguma parte do corpo da cobra, outro valor sera gerado. Quando o valor respeitar essa condição o <code>loop</code> para.</p>
<p>Agora precisamos aumentar o tamanho da cobra, para isso adicionamos um método que ira adicionar um ponto, no fim do corpo da cobra.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Cobra
    ...
    pub fn aumentar_tamanho(&amp;mut self) {
        let ultimo = self.body.last().unwrap().clone();
        self.body.push(ultimo);
    }

}

<span class="boring">}
</span></code></pre></pre>
<p>Para testar esse método é interessante, validarmos o tamanho do corpo e se a posição do ponto adicionado, é igual à posição do último ponto anterior após a cobra se mover.</p>
<p>Agora temos que fazer o jogo funcionar, estamos quase lá.</p>
<p>Vamos criar um arquivo <code>jogo</code> onde teremos a <code>struct Jogo</code>. Aquele mesmo processo de sempre, cria o arquivo, adiciona na <code>lib.rs</code>.</p>
<p>A struct é a mais simples possível, ela é apenas.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Jogo;
<span class="boring">}
</span></code></pre></pre>
<p>Então vamos alterar o método que desenha o tabuleiro para gerar uma <a href="intermediary-02/../intermediary-01/01-strings.html">String</a>, vamos usa-la para desenhar o tabuleiro inteiro de uma vez e também vamos movê-la para a <code>struct Jogo</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Jogo {
    fn gerar_tabuleuro(cobra: &amp;Cobra, petisco: &amp;Ponto, tabuleiro: &amp;(usize, usize)) -&gt; String {
        let mut buffer = String::new();
        for y in 0..tabuleiro.1 {
            for x in 0..tabuleiro.0 {
                if cobra.cabeca == (x, y) {
                    buffer.push_str(&quot;0 &quot;)
                } else if cobra.corpo.contains(&amp;Ponto::new(x, y)) {
                    buffer.push_str(&quot;# &quot;);
                } else if *petisco == (1x, y) {
                    buffer.push_str(&quot;+ &quot;);
                } else {
                    buffer.push_str(&quot;- &quot;);
                }
            }
            buffer.push('\n');
        }
        buffer
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora que fizemos essa alteração, vamos jogar o gerador do petisco para essa mesma struct.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Jogo {
    ...
    fn gerar_petisco(cobra: &amp;Cobra, tabuleiro: &amp;(usize, usize)) -&gt; Point {
        let mut petisco;
        loop {
            let x = rand::thread_rng().gen_range(0..=tabuleiro.0 - 1);
            let y = rand::thread_rng().gen_range(0..=tabuleiro.1 - 1);
            petisco = Point::new(x, y);
            if cobra.cabeca != petisco &amp;&amp; !cobra.corpo.contains(&amp;petisco) {
                break;
            }
        }
        petisco
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>E estamos quase lá, falta apenas um loop infinito, onde, movemos a cobra, limpamos a tela anterior, redesenhamos a tela e capturamos a tecla acionada.
Para facilitar o processo vamos adicionar mais uma dependência no arquivo <code>Cargo.toml</code>, sera dependência <a href="https://crates.io/crates/termion">termion</a>.</p>
<p>Então nosso arquivo ficará parecido com isso:</p>
<pre><code class="language-toml">[package]
name = &quot;snake-game&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[dependencies]

rand = &quot;0.8.5&quot;
termion = &quot;1.5.6&quot;
</code></pre>
<p>Vamos adicionar o método estático na <code>struct Jogo</code> que ira fazer a &quot;mágica&quot; acontecer.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Jogo {
    pub fn run() -&gt; Result&lt;(), &amp;'static str&gt; {
        let mut cobra: Cobra = Default::default();
        let tabuleiro = (15, 15);
        let mut petisco = Self::gerar_petisco(&amp;snake, &amp;tabuleiro);
        let mut stdin = termion::async_stdin().keys();
        loop {
            if cobra.cabeca == snack {
                cobra.aumentar_tamanho();
                petisco = Self::gerar_petisco(&amp;cobra, &amp;tabuleiro);
            } else if cobra.corpo.contains(&amp;cobra.cabeca) {
                return Err(&quot;fim de jogo, a cobra bateu nela mesma&quot;);
            }
            let tabuleiro_jogo = Self::gerar_tabuleuro(&amp;cobra, &amp;petisco, &amp;tabuleiro);
            print!(
                &quot;{}{}{}&quot;,
                termion::clear::All,
                termion::cursor::Goto(1, 1),
                termion::cursor::Hide
            );
            println!(&quot;{}&quot;, tabuleiro_jogo);
            let stdout = io::stdout().into_raw_mode().unwrap();
            let input = stdin.next();
            if let Some(Ok(key)) = input {
                match key {
                    Key::Char('a') | Key::Left =&gt; cobra.alterar_direcao(Direcao::Esquerda),
                    Key::Char('w') | Key::Up =&gt; cobra.alterar_direcao(Direcao::Cima),
                    Key::Char('s') | Key::Down =&gt; cobra.alterar_direcao(Direcao::Baixo),
                    Key::Char('d') | Key::Right =&gt; cobra.alterar_direcao(Direcao::Direita),
                    _ =&gt; {},
                }
            }
            stdout.lock().flush().unwrap();
            thread::sleep(Duration::from_millis(500));
            cobra.passo(tabuleiro)?;
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Esse método agrupa tudo o que nós precisamos, criamos a cobra, criamos o primeiro petisco, definimos o tamanho do tabuleiro e começamos a trabalhar.</p>
<p>Na linha <code>let mut stdin = termion::async_stdin().keys();</code> criamos um modo <a href="https://en.wikipedia.org/wiki/Async/await">assincrono</a> de capturar as teclas digitadas pelo usuário, utilizando a dependencia do <code>termion</code>, assim que entramos no loop, fazemos as primeiras verificações, que são:</p>
<ul>
<li>Validar se a cabeça da cobra está na mesma posição de um petisco
<ul>
<li>Se sim =&gt; seu tamanho aumenta e outro petisco é gerado.</li>
<li>Se não =&gt; valida se a cabeça está na mesma posição de seu corpo
<ul>
<li>Se sim =&gt; encerra o jogo com a mensagem de fim de jogo</li>
<li>Se não =&gt; continua a execução</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Então geramos o tabuleiro e armazenamos em uma variável. Com um método do <code>termion</code>, limpamos o terminal, posicionamos o mouse na primeira posição e escondemos o cursor. Logo em sequência desenhamos tabuleiro do jogo. Transformamos a saída em <a href="https://en.wikipedia.org/wiki/Terminal_mode">raw mode</a>, lemos uma tecla e caso alguma tecla tenha sido pressionada validamos qual foi, em um <code>match</code> assim alteramos a direção que a cobra esta andando caso necessário. Limpamos a saída, esperamos meio segundo com o método <code>thread::sleep(Duration::from_milis(500))</code> e então fazemos a cobra dar mais um passo. O processo todo se repete.</p>
<p>Adicionamos a o nosso <code>main</code> a chamada a esse método:</p>
<pre><pre class="playground"><code class="language-rust">fn main(){
    if let Err(msg) = Game::run() {
        eprintln!(&quot;{}&quot;, msg)
    }
}
</code></pre></pre>
<p>E pronto, temos nosso jogo da cobrinha feito e funcionando, deixo para você os testes finais e adiciono alguns desafios:</p>
<ul>
<li>Faça o jogo pausar</li>
<li>Adicione um placar ao jogo</li>
<li>Quando a cobra alcançar o tamanho máximo (x * y) mostre uma mensagem de vitória e encerre o jogo</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="avançado-1"><a class="header" href="#avançado-1">Avançado 1</a></h1>
<p>Chegamos em um ponto muito interessante, já vimos conceitos básicos e intermediários.
A partir deste ponto iremos abordar assuntos mais avançados da linguagem, é um conteúdo bem denso, então não exite em ler e reler, iremos abordar assuntos como, lifetimes, closures, smart pointers e threads.</p>
<p>Roadmap:</p>
<ul>
<li><a href="advanced-01/./01-lifetimes.html">Lifetimes</a></li>
<li><a href="advanced-01/./02-smart-pointers.html">Smart Pointers</a>
<ul>
<li><a href="advanced-01/./02-smart-pointers-box.html">Box&lt;T&gt;</a></li>
<li><a href="advanced-01/./02-smart-pointers-rc.html">Rc&lt;T&gt;</a></li>
<li><a href="advanced-01/./02-smart-pointers-refcell.html">RefCell&lt;T&gt;</a></li>
</ul>
</li>
<li><a href="advanced-01/./03-closures.html">Closures</a></li>
<li><a href="advanced-01/./04-threads.html">Threads</a>
<ul>
<li><a href="advanced-01/./04-threads-arc-mutex-rwlock.html">Arc&lt;T&gt;, Mutex&lt;T&gt; e RwLock&lt;T&gt;</a></li>
</ul>
</li>
<li><a href="advanced-01/./05-produces-consumers.html">Produtores e Consumidores</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lifetimes"><a class="header" href="#lifetimes">Lifetimes</a></h1>
<p>Lifetimes, a os lifetimes, eles são parte essencial do código Rust, com os lifetimes o <a href="https://rustc-dev-guide.rust-lang.org/borrow_check.html">borrow checker</a> do Rust consegue saber quando liberar a memória de algo, por quanto tempo algo fica &quot;vivo&quot;.</p>
<p>É comum associarmos o lifetime com o escopo, e não esta errado, mas também não esta completamente correto.</p>
<p>Por exemplo no código abaixo o lifetime respeita completamente o escopo.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    {
        let lifetime = &quot;lifetime&quot;;
        println!(&quot;{}&quot;, lifetime);
    } 
    /*
        Terminou o escopo do bloco acima, a memória é liberada,
        fim do lifetime.
    */
}
</code></pre></pre>
<p>Outro ponto importante que devemos considerar é que o dono do recurso é o responsável por devolver a memória ao SO. No código abaixo vemos isso:</p>
<pre><pre class="playground"><code class="language-rust">
fn escreva(texto: String) {
    /*
        Esta função é a responsável por devolver ao sistema operacional
        Todo a memória solicitada.
        Quando ela adquiri o ownership da String ela tem a responsabilidade de
        liberar a memória, vimos isso mais no inicio deste livro,
        até aqui nenhuma novidade.
    */
    println!(&quot;{}&quot;, texto);
}

fn main() {
    escreva(&quot;Rust4noobs&quot;.to_string());
}
</code></pre></pre>
<h2 id="lifetimes-genéricos"><a class="header" href="#lifetimes-genéricos">Lifetimes genéricos</a></h2>
<p>Como assim lifetimes genéricos?</p>
<p>Lembra do capítulo sobre <a href="advanced-01/../intermediary-02/05-generics.html">generics</a>, funciona quase da mesma maneira, temos a seguinte <code>struct</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Life {
    string_slice: &amp;str
}
<span class="boring">}
</span></code></pre></pre>
<p>Notem que temos uma referência dentro da struct, isso é um problema, o compilador do Rust não sabe até quando essa referência irá viver, e é neste ponto que o lifetime começa a deixar de ser apenas relacionado ao escopo.</p>
<p>Ao tentar compilar o código acima, temos o seguinte erro.</p>
<pre><code class="language-sh">error[E0106]: missing lifetime specifier
 --&gt; test.rs:3:23
  |
3 |         string_slice: &amp;str
  |                       ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
2 ~     struct Life&lt;'a&gt; {
3 ~         string_slice: &amp;'a str
  |

error: aborting due to previous error

For more information about this error, try `rustc --explain E0106`.
</code></pre>
<p>Precisamos, informar o lifetime deste <code>string slice</code>, como sugere o compilador, note que a sintaxe é muito parecida com a dos <code>generics</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Life&lt;'a&gt; {
    string_slice: &amp;'a str
}
<span class="boring">}
</span></code></pre></pre>
<p>E agora vemos que nosso código compila. Claro, não perdemos os poderes dos <code>generics</code> fazendo isso e não nos limitamos apenas as <code>structs</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Life&lt;'a, T&gt; {
    data: &amp;'a T
}

impl&lt;'a, T&gt; Life&lt;'a, T&gt; {
    fn new(data: &amp;'a T) -&gt; Self {
        Self {
            data
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>No exemplo acima adicionei os <code>generics</code> e o lifetime, juntos e também em uma implementação. A lógica para fazer isto em um método é a mesma.</p>
<h3 id="menor-lifetime"><a class="header" href="#menor-lifetime">Menor lifetime</a></h3>
<p>Uma coisa que devemos considerar é que, quando tivermos duas referências, o compilador do rust sempre irá considerar o menor lifetime, por exemplo.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = &quot;abc&quot;;
    {
        let b = &quot;a&quot;;
        let maior = maior(a, b);
        println!(&quot;{}&quot;, maior);
    }
}

fn maior&lt;'a&gt;(a: &amp;'a str, b: &amp;'a str) -&gt; &amp;'a str {
    if a.len() &gt; b.len() {
        a
    } else {
        b
    }
}
</code></pre></pre>
<p>Neste exemplo o compilador do Rust assume o lifetime da variável <code>b</code> para o lifetime da função. Outro ponto que devemos considerar é que podem existir mais de um lifetime, se pegarmos este mesmo código acima, adicionarmos um segundo lifetime e usarmos o mesmo para o parâmetro <code>b</code> para outro nome de lifetime, estaremos informando que esta função pode ter dois lifetimes possíveis.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = &quot;abc&quot;;
    {
        let b = &quot;a&quot;;
        let maior = maior(a, b);
        println!(&quot;{}&quot;, maior);
    }
}

fn maior&lt;'a, 'b&gt;(a: &amp;'a str, b: &amp;'b str) -&gt; &amp;'a str {
    if a.len() &gt; b.len() {
        a
    } else {
        b
    }
}
</code></pre></pre>
<p>Ao tentarmos compilar o código acima teremos o seguinte erro</p>
<pre><code class="language-sh">error[E0623]: lifetime mismatch
  --&gt; test.rs:14:9
   |
10 | fn maior&lt;'a, 'b&gt;(a: &amp;'a str, b: &amp;'b str) -&gt; &amp;'a str {
   |                                 -------     -------
   |                                 |
   |                                 this parameter and the return type are declared with different lifetimes...
...
14 |         b
   |         ^ ...but data from `b` is returned here

error: aborting due to previous error

For more information about this error, try `rustc --explain E0623`.

</code></pre>
<p>Vamos entender um pouco melhor o que acontece ali. Temos dois lifetimes, então o compilador entende que podemos ter duas referências que vivem tempos diferentes, porém não é possível retornar a variável <code>b</code>, pois não temos garantia que o parâmetro <code>b</code>ira viver mais ou menos que o parâmetro <code>a</code>, então não podemos ter ele como retorno, a função do modo que ficou agora somente pode retornar o parâmetro <code>a</code>.</p>
<p>Mas qual seria a utilidade disso? Basicamente, você consegue utilizar essa variação de lifetimes para processar dados que vão viver tempos diferentes, como por exemplo um valor que irá viver apenas dentro daquela função como já foi explicado no capítulo de <a href="advanced-01/../intermediary-01/05-slices.html">slices</a>, caso um resultado de uma função dependa de dois lifetimes em uma struct por exemplo, podemos informar ao compilador utilizando mais de um parâmetro de lifetime. No livro <a href="https://nostarch.com/rust-rustaceans">Rust for Rustaceans</a> podemos encontrar um exemplo bem interessante sobre este assunto.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="smart-pointers"><a class="header" href="#smart-pointers">Smart Pointers</a></h1>
<p>Este é um ponto muito interessante na linguagem, Smart Pointers é um modo que podemos utilizar em Rust para acessar a <code>heap</code>, claro eles são mais do que isso, eles implementam traits como <code>Deref</code>, <code>DerefMut</code>, etc.
Neste ponto, iremos falar sobre 3 Smart Pointers sendo eles: Box&lt;T&gt;, Rc&lt;T&gt; e RefCell&lt;T&gt;, todos com sua particularidade e casos de uso.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="boxt"><a class="header" href="#boxt">Box&lt;T&gt;</a></h1>
<p>O <code>Smart Pointer</code> Box<T>, é bem versátil, ele aponta para a <code>heap</code> e também implementa as <a href="advanced-01/../intermediary-02/06-traits.html">traits</a> <code>Deref</code> e <code>DerefMut</code>, sendo assim, é possível apontar para um endereço de moria na Heap e realizar modificações nesta região de memória. Vamos a um exemplo mais simples.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numero: Box&lt;usize&gt; = Box::new(42);
    println!(&quot;{}&quot;, numero);
}
</code></pre></pre>
<p>Neste exemplo acima, apontamos para uma região da <code>heap</code>, um número inteiro sem sinal, o Box, obedece às mesmas regras de <a href="advanced-01/../intermediary-01/03-ownership.html">ownership</a> que ponteiros comuns.</p>
<p>Como ele foi declarado como imutável, não podemos fazer o <code>DerefMut</code> e alterar o valor na heap, caso tentarmos fazer isso teremos o seguinte erro.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numero: Box&lt;usize&gt; = Box::new(42);
    *numero = 69;
    println!(&quot;{}&quot;, numero);
}
</code></pre></pre>
<pre><code class="language-sh">error[E0594]: cannot assign to `*numero`, as `numero` is not declared as mutable
 --&gt; boxx.rs:4:5
  |
3 |     let numero = Box::new(1);
  |         ------ help: consider changing this to be mutable: `mut numero`
4 |     *numero = 69;
  |     ^^^^^^^^^^^^ cannot assign

error: aborting due to previous error

For more information about this error, try `rustc --explain E0594`.
</code></pre>
<p>Declarando a variável como mutável podemos realizar essa alteração.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut numero: Box&lt;usize&gt; = Box::new(42);
    *numero = 69;
    println!(&quot;{}&quot;, numero);
}
</code></pre></pre>
<h2 id="tipos-recursivos"><a class="header" href="#tipos-recursivos">Tipos recursivos</a></h2>
<p>Tipos recursivos, são aqueles que tem algum atributo que é representa ele mesmo. Como, por exemplo, em uma árvore binaria, cada &quot;galho&quot; é um tipo recursivo.</p>
<pre><pre class="playground"><code class="language-rust">struct Galho {
    esquerda: Option&lt;Galho&gt;,
    direita: Option&lt;Galho&gt;,
    valor: usize,
}

fn main() {
    todo!();
}
</code></pre></pre>
<p>Caso tentarmos compilar o código acima teremos o seguinte output do compilador:</p>
<pre><code class="language-sh">error[E0072]: recursive type `Galho` has infinite size
 --&gt; recursive.rs:2:1
  |
2 | struct Node {
  | ^^^^^^^^^^^ recursive type has infinite size
3 |     esquerda: Option&lt;Galho&gt;,
  |           ------------ recursive without indirection
4 |     direita: Option&lt;Galho&gt;,
  |            ------------ recursive without indirection
  |
help: insert some indirection (e.g., a `Box`, `Rc`, or `&amp;`) to make `Node` representable
  |
3 ~     esquerda: Option&lt;Box&lt;Galho&gt;&gt;,
4 ~     direita: Option&lt;Box&lt;Galho&gt;&gt;,
  |

error: aborting due to previous error

For more information about this error, try `rustc --explain E0072`.

</code></pre>
<p>O próprio compilador já nos diz algo que podemos fazer para corrigir este problema, mas antes vamos entender o que seria essa mensagem aqui &quot;recursive type has infinite size&quot;.</p>
<p>Teoricamente tipos recursivos podem crescer ao infinito e o compilador do Rust não sabe o quanto de memória sera necessário para esse tipo, por isso essa mensagem. Porém, ele sabe exatamente quanta memória é necessária para um <code>Box</code>, sendo possível a criação deste tipo recursivo utilizando esse <code>Box</code>.</p>
<pre><pre class="playground"><code class="language-rust">struct Galho {
    esquerda: Option&lt;Box&lt;Galho&gt;&gt;,
    direita: Option&lt;Box&lt;Galho&gt;&gt;,
    valor: usize,
}

fn main() {
    todo!();
}
</code></pre></pre>
<p>No livro <a href="https://doc.rust-lang.org/book/ch15-01-box.html">Rust Book</a> é possível ver um exemplo bem interessante utilizando uma <a href="https://en.wikipedia.org/wiki/Cons">Cons List</a>.</p>
<h2 id="valores-dinâmicos"><a class="header" href="#valores-dinâmicos">Valores Dinâmicos</a></h2>
<p>Recuperando o exemplo das traits de animais do capítulo sobre <a href="advanced-01/../intermediary-02/06-traits.html">traits</a></p>
<p>Vamos supor que queremos ter uma lista de animais, sendo eles do tipo Cachorro, Gato e Papagaio. Podemos utilizar a palavra reservada <code>dyn</code> dentro de um <code>Box&lt;T&gt;</code>, para representar valores dinâmicos.</p>
<pre><pre class="playground"><code class="language-rust">trait Animal {
    fn comer(&amp;self);
}

struct Cachorro {}

impl Animal for Cachorro {
    fn comer(&amp;self) {
        println!(&quot;Cachorro comendo...&quot;);
    }
}

struct Gato {}

impl Animal for Gato {
    fn comer(&amp;self) {
        println!(&quot;gato comendo...&quot;);
    }
}

struct Papagaio {}

impl Animal for Papagaio {
    fn comer(&amp;self) {
        println!(&quot;papagaio comendo...&quot;);
    }
}
fn main() {
    let animais: Vec&lt;Box&lt;dyn Animal&gt;&gt; = vec![
        Box::new(Gato {}),
        Box::new(Cachorro {}),
        Box::new(Papagaio {}),
    ];
    for animal in animais {
        animal.comer();
    }
}
</code></pre></pre>
<p>Utilizando valores dinâmicos podemos ter tipos diferentes que implementam a mesma trait. Só devemos saber que, um ponteiro dinâmico ocupa o dobro do espaço que um ponteiro comum, isso por que temos um ponteiro para o tipo em questão e outro ponteiro para a implementação desta <code>trait</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rct"><a class="header" href="#rct">Rc&lt;T&gt;</a></h1>
<p>Rc&lt;T&gt; é um tipo de <code>Smart Pointer</code> com contagem de referências, o seu nome vem de <code>Reference Counting</code>, parecido com o <a href="advanced-01/02-smart-pointers-box.html">Box&lt;T&gt;</a>, porém com contagem de referências e sem a implementação da <code>trait DerefMut</code>, sendo assim é um tipo de <code>Smart Pointer</code> imutável. Sua declaração é parecida com a de um Box&lt;T&gt;, mas o que vai diferenciá-lo?</p>
<p>Vamos supor que temos o seguinte código:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numero = Box::new(69);
    escreva(numero);
    faca_qualquer_coisa(numero);
}

fn faca_qualquer_coisa&lt;T&gt;(valor: Box&lt;T&gt;) {
    todo!()
}

fn escreva&lt;T: std::fmt::Display&gt;(valor: Box&lt;T&gt;) {
    println!(&quot;valor = {}&quot;, valor)
}
</code></pre></pre>
<p>O código acima ira nos retornar o seguinte erro:</p>
<pre><code class="language-sh">error[E0382]: use of moved value: `numero`
 --&gt; ref-count.rs:4:25
  |
2 |     let numero = Box::new(69);
  |         ------ move occurs because `numero` has type `Box&lt;i32&gt;`, which does not implement the `Copy` trait
3 |     escreva(numero);
  |             ------ value moved here
4 |     faca_qualquer_coisa(numero);
  |                         ^^^^^^ value used here after move

error: aborting due to previous error; 1 warning emitted

For more information about this error, try `rustc --explain E0382`.
</code></pre>
<p>Isso acontece  justamente pelas regras de <a href="advanced-01/../intermediary-01/03-ownership.html">ownership</a> do Rust. Um modo para contornarmos esse problema seria utilizando o Rc&lt;T&gt;, e aqui que ele tem uma vantagem. Por ser uma referência compartilhada podemos clonar esta referência, claro apenas as informações necessárias, como o endereço de memória e... Só.</p>
<pre><pre class="playground"><code class="language-rust">use std::rc::Rc;

fn main() {
    let numero = Rc::new(69);
    escreva(Rc::clone(&amp;numero));
    faca_qualquer_coisa(Rc::clone(&amp;numero));
}

fn faca_qualquer_coisa&lt;T&gt;(valor: Rc&lt;T&gt;) {
    todo!()
}

fn escreva&lt;T: std::fmt::Display&gt;(valor: Rc&lt;T&gt;) {
    println!(&quot;valor = {}&quot;, valor)
}
</code></pre></pre>
<p>Realizamos o clone pelo chamando a implementação da <code>struct</code> Rc&lt;T&gt;, mas nada nos impede de chamar o método <code>.clone()</code> da instância, porém não é o padrão utilizado por ai.</p>
<p>Este tipo de ponteiro, somente irá liberar a memória alocada quando o seu contador de referências chegar a 0. Ou seja, ninguém mais, apontar para aquela região de memória. No exemplo abaixo, podemos ver como saber o atual valor deste contador.</p>
<pre><pre class="playground"><code class="language-rust">use std::rc::Rc;

fn main() {
    let referência = Rc::new(42);
    println!(&quot;contador atual esta em: {}&quot;, Rc::strong_count(&amp;referência));
    let segunda_referência = Rc::clone(&amp;referência);
    println!(&quot;contador atual esta em: {}&quot;, Rc::strong_count(&amp;referência));
    {
        let terceira_referência = Rc::clone(&amp;segunda_referência);
        println!(&quot;contador atual esta em: {}&quot;, Rc::strong_count(&amp;referência));
    }
    println!(&quot;contador atual esta em: {}&quot;, Rc::strong_count(&amp;referência));
} 
/*
    após o fim do escopo da função main, o contador chega a '0'
    a memória é liberada.
*/
</code></pre></pre>
<p>A saída do programa acima é:</p>
<pre><code class="language-sh">contador atual esta em: 1
contador atual esta em: 2
contador atual esta em: 3
contador atual esta em: 2
</code></pre>
<p>Repare que o valor do contador muda, independente de realizar o <code>clone</code> a partir da primeira referência, ou da segunda referência, isso acontece, porque os dois apontam para o mesmo local da memória.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="refcellt"><a class="header" href="#refcellt">RefCell&lt;T&gt;</a></h1>
<p>Sinceramente, quando comecei a escrever este tópico sobre os <code>Smart Pointers</code> eu achei que seria mais fácil explicar sobre este carinha aqui. Porém, para estar mais enganado, somente se eu falar que Java é lento.</p>
<p>RefCell&lt;T&gt; é como uma caixa de pandora, você precisa de muito cuidado e muita certeza do que esta fazendo quando o utiliza, este <code>Smart Pointer</code> tem checagem de &quot;empréstimo&quot;  em tempo de execução. Esta checagem obedece às mesmas regras de <a href="advanced-01/../intermediary-01/03-ownership.html">ownership</a> que já conhecemos:</p>
<ul>
<li>referências imutáveis = &quot;ilimitadas&quot;</li>
<li>referências mutáveis = exclusivas</li>
</ul>
<p>O código abaixo, não tem problemas de compilação.</p>
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;

fn main() {
    let referência = RefCell::new(42);
    let referência_imutavel = referência.borrow();
    println!(&quot;{}&quot;, referência_imutavel);
    {
        let outra_imutavel = referência.borrow();
        println!(&quot;{}&quot;, outra_imutavel);
    }
    let mut referência_mutavel = referência.borrow_mut();
    *referência_mutavel = 69;
    println!(&quot;{}&quot;, referência_mutavel);
}
</code></pre></pre>
<p>Podemos pensar &quot;se compilou esta certo&quot;, porém temos um pequeno problema na hora de executar este programa.</p>
<pre><code class="language-sh">42
thread 'main' panicked at 'already borrowed: BorrowMutError', ref-cell.rs:7:45
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>E é aqui que as coisas começam a complicar, vamos no famoso <code>baby step</code>, com calma, uma coisa e cada vez. Eu sei que pode ser confuso a primeira vista o programa compilar, sem problemas de <code>ownership</code> e na hora da execução esses problemas estourarem.</p>
<p>Os dados contidos dentro desse ponteiro são expostos de maneiras específicas, sendo possível expor de maneira imutável ou mutável. Tente pensar como se fosse uma caixa fechada com um conteúdo dentro dela. Esta caixa pode deixar várias pessoas verem o que tem dentro dela através de um furo, por exemplo, porém quando este conteúdo vai ser modificado este furo é tampado, não sendo mais possível que mais de uma pessoa visualize o que tem dentro desta caixa, até que esta mudança termine de ser feita.</p>
<h2 id="mutabilidade-interior"><a class="header" href="#mutabilidade-interior">Mutabilidade interior</a></h2>
<p>&quot;Em Rust alguns tipos precisam ser alterados enquanto compartilhados&quot;. - https://doc.rust-lang.org/reference/interior-mutability.html </p>
<p>Isso soa meio confuso, mas pense um tipo tem uma mutabilidade interior, quando o seu conteúdo pode ser modificado por meio de uma referência compartilhada por ele mesmo. Isto vai contra muitas coisas que aprendemos até agora. Foi o que aconteceu no nosso exemplo de <code>RefCell\&lt;T&gt;</code>, claro este não é o único tipo a implementar este tipo de comportamento, temos também <code>Cell</code>. Podemos criar o nosso próprio tipo usando <code>UnsafeCell</code>.</p>
<h2 id="retomando"><a class="header" href="#retomando">Retomando</a></h2>
<p>Respeitando as regras de <code>ownership</code> podemos resolver os problemas do código mostrado.</p>
<ul>
<li>Não devemos permitir mais de uma referência, quando temos uma referência mutável.</li>
<li>referências mutáveis, são &quot;infinitas&quot;, desde que não tenhamos referencias mutáveis.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;

fn main() {
    let referência = RefCell::new(42);
    
    let referência_imutavel = referência.borrow();
    
    println!(&quot;{}&quot;, referência_imutavel);
    {
        let outra_imutavel = referência.borrow();
        println!(&quot;{}&quot;, outra_imutavel);
    }
    drop(referência_imutavel); 
    let mut referência_mutavel = referência.borrow_mut();
    *referência_mutavel = 69;
    
    println!(&quot;{}&quot;, referência_mutavel);
}
</code></pre></pre>
<p>Podemos corrigir o problema com algo bem interessante, no Rust temos um modo dizer &quot;olha, pode devolver isso daqui pro sistema operacional&quot;, um método chamado <code>drop</code>, podemos utilizar ele para dizer que a referência imutável não sera mais utilizada, sendo assim podemos fazer um <code>borrow_mut</code>, naquele valor. </p>
<h2 id="múltiplas-referências-mutáveis"><a class="header" href="#múltiplas-referências-mutáveis">Múltiplas referências mutáveis.</a></h2>
<p>Até agora aprendemos sobre o <code>Rc&lt;T&gt;</code> e o <code>RefCell&lt;T&gt;</code>, e claro podemos combinar os dois para criar múltiplas referências de algo que também podem ser mutáveis, vamos ao exemplo:</p>
<pre><pre class="playground"><code class="language-rust">use std::{
    cell::RefCell,
    rc::Rc,
};

#[derive(Debug)]
struct NomeGenerico {
    criatividade: Option&lt;Rc&lt;RefCell&lt;NomeGenerico&gt;&gt;&gt;,
    valor: usize
}

fn main() {
    let nome_generico = Rc::new(RefCell::new(NomeGenerico {
        criatividade: None,
        valor: 10
    }));
    let outra_referência = Rc::clone(&amp;nome_generico);
    let mut referência_mutavel = nome_generico.borrow_mut();
    referência_mutavel.valor = 20;
    println!(&quot;{:#?}&quot;, nome_generico);
    println!(&quot;{:#?}&quot;, outra_referência);
}
</code></pre></pre>
<p>Ao compilar e executar o código acima teremos o seguinte output:</p>
<pre><code class="language-sh">RefCell {
    value: &lt;borrowed&gt;,
}
RefCell {
    value: &lt;borrowed&gt;,
}
</code></pre>
<p>O valor do RefCell, teve um &quot;borrow&quot;, ou seja, esta ali, mas não está. Mas, esse não é o ponto que queremos chegar, reparem que eu tive duas referências imutáveis, realizei um <code>borrow_mut</code> e não tive erro em tempo de execução? Perceba que &quot;burlamos&quot; este ponto que foi uma pequena dor de cabeça anteriormente. Note que não precisamos dar um <code>drop</code> em referências anteriores, etc. Bem legal né?</p>
<p>Agora temos que encarar outro problema, referência cíclica e vazamento de memória.</p>
<pre><pre class="playground"><code class="language-rust">use std::{
    cell::RefCell,
    rc::Rc,
};

#[derive(Debug)]
struct NomeGenerico {
    criatividade: Option&lt;Rc&lt;RefCell&lt;NomeGenerico&gt;&gt;&gt;,
    valor: usize
}

fn main() {
    let nome_generico = Rc::new(RefCell::new(NomeGenerico {
        criatividade: None,
        valor: 10
    }));
    let outra_referência = Rc::clone(&amp;nome_generico);
    {
        let mut referência_mutavel = nome_generico.borrow_mut();
        referência_mutavel.valor = 20;
        referência_mutavel.criatividade = Some(Rc::clone(&amp;outra_referência));
    }
    println!(&quot;{:#?}&quot;, nome_generico);
    println!(&quot;{:#?}&quot;, outra_referência);
}
</code></pre></pre>
<p>Ao compilar o código acima e executar teremos uma chamada recursiva até um <a href="https://www.techtarget.com/whatis/definition/stack-overflow">stack overflow</a> acontecer. Claro você não vai ver esse tipo de código a todo momento.</p>
<p>O que pode causar o vazamento de memória é o modo em que são ligados as referências, podendo chegar a um ponto onde um <code>Rc&lt;T&gt;</code>, tenha o contador zerado e não exista mais referências a serem &quot;dropadas&quot;.</p>
<h2 id="referência-fraca"><a class="header" href="#referência-fraca">referência Fraca</a></h2>
<p>Um modo de contornarmos o problema acima é ao invés de utilizar um <code>Rc&lt;T&gt;</code> que é uma referência forte, podemos usar um <code>Weak&lt;T&gt;</code>, a grande diferença é que um <code>Rc&lt;T&gt;</code> tem um contador de referências fortes e fracas, as referências fracas não são tão importantes assim, ou seja, caso o contador de referências fortes chegue a 0 e ainda existirem referências fracas, a memória é liberada mesmo assim, em contrapartida, se tentarmos acessar a memória dessa referência fraca podemos ter um problema de acesso à memória indefinida, ou seja, memória que não pertence aquele processo.</p>
<pre><pre class="playground"><code class="language-rust">use std::{
    cell::RefCell,
    rc::{Rc, Weak},
};

#[derive(Debug)]
struct NomeGenerico {
    criatividade: Option&lt;Weak&lt;RefCell&lt;NomeGenerico&gt;&gt;&gt;,
    valor: usize
}

fn main() {
    let nome_generico = Rc::new(RefCell::new(NomeGenerico {
        criatividade: None,
        valor: 10
    }));
    let outra_referência = Rc::clone(&amp;nome_generico);
    {
        let mut referência_mutavel = nome_generico.borrow_mut();
        referência_mutavel.valor = 20;
        referência_mutavel.criatividade = Some(Rc::downgrade(&amp;outra_referência));
    }
    println!(&quot;referências fracas: {}&quot;, Rc::weak_count(&amp;nome_generico));
    println!(&quot;referências fortes: {}&quot;, Rc::strong_count(&amp;nome_generico));
    println!(&quot;{:#?}&quot;, nome_generico);
    println!(&quot;{:#?}&quot;, outra_referência);
}
</code></pre></pre>
<p>Ao compilar e executar o código acima teremos a seguinte saída:</p>
<pre><code class="language-sh">referências fracas: 1
referências fortes: 2
RefCell {
    value: NomeGenerico {
        criatividade: Some(
            (Weak),
        ),
        valor: 20,
    },
}
RefCell {
    value: NomeGenerico {
        criatividade: Some(
            (Weak),
        ),
        valor: 20,
    },
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="closures"><a class="header" href="#closures">Closures</a></h1>
<p>Closures em Rust são as funções anônimas, ou seja, funções que podem ou não ter algum nome. Vamos começar com exemplos mais simples e fáceis.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let somar = |x, y| x + y;
    let valor = somar(1, 2);
    println!(&quot;{}&quot;, valor);
}
</code></pre></pre>
<p>O código acima tem como saída:</p>
<pre><code class="language-sh">3
</code></pre>
<p>Os tipos para uma closure podem ser diversos, caso quiséssemos declarar o tipo da <code>closure</code> faríamos da seguinte maneira:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let somar = |x: i32, y: i32| x + y;
    let valor = somar(1, 2);
    println!(&quot;{}&quot;, valor);
}
</code></pre></pre>
<p>Precisamos desse tipo de anotação, pois nem sempre o compilador consegue distinguir o tipo dos argumentos.</p>
<h3 id="funções-como-argumento"><a class="header" href="#funções-como-argumento">Funções como argumento</a></h3>
<p>É possível passar essas closures como o argumento de outra função. No exemplo abaixo, temos uma lista de números, transformamos em um iterador e chamamos o método <code>for_each</code> passando como argumento a função anônima que escreve no terminal o valor de 'x'.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numeros = vec![1, 2, 3, 4];
    numeros.iter().for_each(|x| println!(&quot;{}&quot;, x));
}
</code></pre></pre>
<p>Podemos aproveitar do exemplo anterior e utilizar outra função, como o map para dar como saída outra coleção e fazer chamadas encadeadas. </p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numeros = vec![1, 2, 3, 4];
    numeros
        .iter()
        .map(|x| {
            let mut valor = *x;
            if valor % 2 == 0 {
                valor += 10;
            } else {
                valor *= 10
            }
            valor
        })
        .for_each(|x| println!(&quot;{x}&quot;))
}
</code></pre></pre>
<p>As closures são bem poderosas e podemos utilizar elas de forma a ganhar flexibilidade em nossos códigos.</p>
<h2 id="move"><a class="header" href="#move">Move?</a></h2>
<p>Para este exemplo vamos implementar a sequência de Fibonacci, para isso vamos escrever uma função que retorna outra função. Espera... Uma função que retorna outra? Isso mesmo</p>
<pre><pre class="playground"><code class="language-rust">fn fibonacci() -&gt; impl FnMut() -&gt; usize {
    let mut a = 0;
    let mut b = 1;
    return move || {
        a = b;
        b = a + b;
        return b - a;
    };
}

fn main() {
    let mut f = fibonacci();

    for i in 0..10 {
        println!(&quot;{}&quot;, f());
    }
}

</code></pre></pre>
<p>O código acima ira nos devolver os 10 primeiros números da sequência de Fibonacci, aqui temos dois assuntos interessantes para tratar, o primeiro a palavra &quot;impl&quot; no retorno, o segundo a trait &quot;FnMut&quot; e uma segunda declaração do tipo de retorno? Como assim?</p>
<ul>
<li>impl: assim como a palavra reservada 'dyn', existe a palavra reservada 'impl' que pode ser usada para representar algum tipo dinâmico alocado na <code>stack</code> ao invés da <code>heap</code>.</li>
<li>FnMut: <code>FnMut</code> assim como <code>Fn</code> e <code>FnOnce</code>, são traits que podem ser implementadas por de Closures, sendo elas, <code>FnMut</code> com valores mutáveis, <code>Fn</code> com valores imutáveis e <code>FnOnce</code> com valores imutáveis, sendo possível apenas uma única chamada.</li>
<li>Segunda declaração de retorno: essa segunda declaração de retorno é nada mais nada menos que a declaração do retorno dessa <code>FnMut</code>, que também pode ser receber parâmetros como, por exemplo: <code>FnMut(i32) -&gt; i32</code>, com argumentos na trait separados por virgula, <code>FnMut(Box&lt;Foo&gt;, i32) -&gt; Bar</code>;</li>
</ul>
<p>No corpo de nossa função temos uma palavrinha nova ali que á o <code>move</code>, esta palavra reservada indica que as variáveis 'a' e 'b', serão movidas para dentro do contexto da Closure.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="threads"><a class="header" href="#threads">Threads</a></h1>
<p>Afinal, o que são Threads? Podemos considerar threads como sub processos que compartilham da mesma memória, diferente de estratégias como &quot;fork&quot; que é feita uma cópia do processo com espeço de memória isolado, as threads são sempre do mesmo processo e custam menos para serem criadas.</p>
<p>Estas threads são executadas de forma assíncrona, ou seja, todas de uma vez, claro existem estratégias para a execução dessa thread que o seu sistema operacional provavelmente usa. </p>
<h2 id="threads-em-rust"><a class="header" href="#threads-em-rust">Threads em Rust</a></h2>
<p>Quando um processo é criado temos a thread principal, que parte a partir da função <code>main</code>, a partir desta threads conseguimos criar threads novas.</p>
<pre><pre class="playground"><code class="language-rust">use std::thread;

fn main() {
    thread::spawn(|| {
        println!(&quot;Hello World!&quot;);
    });
}
</code></pre></pre>
<p>Notem que utilizamos uma <a href="advanced-01/./03-closures.html">closure</a> para dizer qual o comportamento que esta thread terá. Ao executarmos este programa temos o segu... espera, não temos output, como assim? A thread não executou? Sim, ela executou, porém, não teve tempo o suficiente para escrever a mensagem na saída, já que a criação de uma thread não bloqueia a thread que a criou, ela continua sendo executada, o que podemos fazer para bloquear a thread que criou a thread é chamar o método 'join', do valor retornado por esse método <code>thread::spawn</code>,  ele nos retorna um <code>JoinHandle&lt;T&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust">use std::thread::{self, JoinHandle};

fn main() {
    let handle: JoinHandle&lt;()&gt; = thread::spawn(|| {
        println!(&quot;Hello World!&quot;);
    });
    handle.join().unwrap();
}
</code></pre></pre>
<p>Agora executando o código acima, criamos uma segunda thread, e bloqueamos a thread principal, quando a thread criada termina sua execução a thread principal é liberada. Também é possível recuperar um valor de dentro da thread, basta a <code>closure</code> retornar um valor.</p>
<pre><pre class="playground"><code class="language-rust">use std::thread::{self, JoinHandle};

fn main() {
    let handle: JoinHandle&lt;usize&gt; = thread::spawn(|| 42);
    let valor = handle.join().unwrap();
    println!(&quot;valor da retornado pela thread = {}&quot;, valor);
}
</code></pre></pre>
<p>Vamos fazer um teste com mais threads agora, cada uma imprimindo um valor de 0 a 10 e bloqueando a thread principal até o termino dessa execução.</p>
<pre><pre class="playground"><code class="language-rust">use std::thread;

fn main() {
    let handle1 = thread::spawn(|| {
        for i in 0..10 {
            println!(&quot;da thread 1: {i}&quot;);
        }
    });
    let handle2 = thread::spawn(|| {
        for i in 0..10 {
            println!(&quot;da thread 2: {i}&quot;);
        }
    });
    let handle3 = thread::spawn(|| {
        for i in 0..10 {
            println!(&quot;da thread 3: {i}&quot;);
        }
    });
    handle1.join().unwrap();
    handle2.join().unwrap();
    handle3.join().unwrap();
}
</code></pre></pre>
<p>Note que cada execução vai gerar uma saída diferente, pode ser que a thread 1 execute primeiro, e logo em sequência a 3, pode ser que elas se misturem, isso acontece justamente por serem executadas de forma assíncrona.</p>
<h2 id="concorrência-e-paralelismo"><a class="header" href="#concorrência-e-paralelismo">Concorrência e paralelismo</a></h2>
<p>Concorrência e paralelismo são temas diferentes que andam lado a lado, paralelismo foi o que fizemos no exemplo anterior, executamos códigos de modo paralelo, ou seja, simultaneamente, já a concorrência aconteceria quando esses códigos paralelos tentassem acessar o mesmo recurso, Rust foi pensado para ser <code>thread safe</code>, ou seja, seguro para trabalhar com threads.</p>
<p>Se tentarmos usar o código abaixo não teremos sucesso em sua compilação.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    use std::thread;
    let mut a = 10;
    thread::spawn(|| {
        a = 20;
    }).join().unwrap();
    thread::spawn(|| {
        println!(&quot;a = {}&quot;, a);
    }).join().unwrap();
}
</code></pre></pre>
<p>Ai você pensa &quot;hm... o compilador disse para eu mover o valor de um lugar para o outro, vou fazer isso&quot;.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    use std::thread;
    let mut a = 10;
    thread::spawn(move || {
        a = 20;
    }).join().unwrap();
    thread::spawn(move || {
        println!(&quot;a = {}&quot;, a);
    }).join().unwrap();
}
</code></pre></pre>
<p>Movemos o valor, e a bloqueamos a thread até o fim da execução e... 'a = 10'? Ué. Espera, aprendemos sobre o <code>Rc&lt;T&gt;</code> e sobre o <code>RefCell&lt;T&gt;</code>, vou criar uma referência mutável e compartilhada.</p>
<pre><pre class="playground"><code class="language-rust">use std::{cell::RefCell, rc::Rc, thread};

fn main() {
    let mut a = Rc::new(RefCell::new(10));
    let t2 = Rc::clone(&amp;a);
    thread::spawn(move || {
        *t2.borrow_mut() = 42;
    }).join().unwrap();
    thread::spawn(move || {
        println!(&quot;a = {:?}&quot;, a);
    }).join().unwrap();
}

</code></pre></pre>
<p>Outro erro:</p>
<pre><code class="language-sh">error[E0277]: `Rc&lt;RefCell&lt;i32&gt;&gt;` cannot be sent between threads safely
   --&gt; src/main.rs:6:19
    |
6   |       let handle1 = thread::spawn(move || {
    |  ___________________^^^^^^^^^^^^^_-
    | |                   |
    | |                   `Rc&lt;RefCell&lt;i32&gt;&gt;` cannot be sent between threads safely
7   | |         *t2.borrow_mut() = 42;
8   | |     });
    | |_____- within this `[closure@src/main.rs:6:33: 8:6]`
    |
    = help: within `[closure@src/main.rs:6:33: 8:6]`, the trait `Send` is not implemented for `Rc&lt;RefCell&lt;i32&gt;&gt;`
note: required because it's used within this closure
   --&gt; src/main.rs:6:33
    |
6   |       let handle1 = thread::spawn(move || {
    |  _________________________________^
7   | |         *t2.borrow_mut() = 42;
8   | |     });
    | |_____^
note: required by a bound in `spawn`
   --&gt; /home/pgjbz/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/mod.rs:653:8
    |
653 |     F: Send + 'static,
    |        ^^^^ required by this bound in `spawn`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `closures` due to previous error

</code></pre>
<p>Vamos parar e pensar um pouco... Por que nossa primeira tentativa não deu certo?</p>
<p>Quando utilizamos um tipo que implementa a <code>trait</code> Copy ao ser passada para outro contexto é feita uma cópia inteira de seu valor, ou seja, é feita uma passagem por valor e não por referência, por isso apenas utilizar o <code>move</code> para mover a variável de contexto não da exito no que queremos fazer.</p>
<p>O segundo erro acontece porque os tipos <code>Rc&lt;T&gt;</code> e <code>RefCell&lt;T&gt;</code>, não são tipos seguros para serem mandados através das threads, ou seja, eles não têm segurança para threads. Por isso iremos ver sobre os tipos <code>Arc&lt;T&gt;</code>, <code>Mutex&lt;T&gt;</code>, e <code>RwLock&lt;T&gt;</code> que implementam <code>traits</code> como <code>Send</code> e <code>Sync</code>.</p>
<h2 id="scope"><a class="header" href="#scope">Scope</a></h2>
<p>A partir da versão <code> 1.63.0</code> do Rust temos um novo modo de usar <code>threads</code> que é utilizando a função <code>scope</code>, essa função basicamente cria um escopo onde podemos criar <code>threads</code>, e manipular os dados, é feito um <code>join</code> automático em todas as threads criadas dentro deste escopo e o compilador do Rust entende que esses dados podem ser usados &quot;sem riscos&quot;.</p>
<p>Vamos utilizar o exemplo do <a href="https://blog.rust-lang.org/2022/08/11/Rust-1.63.0.html">Rust Blog</a> e entender o que acontece nele.</p>
<pre><pre class="playground"><code class="language-rust">use std::thread::scope;

fn main() {
    let mut a = vec![1, 2, 3];
    let mut x = 0;

    scope(|s| {
        s.spawn(|| {
            println!(&quot;ola a partir da primeira thread por escopo&quot;);
            dbg!(&amp;a);
        });
        s.spawn(|| {
            println!(&quot;ola a partir da segunda thread por escopo&quot;);
            x += a[0] + a[2];
        });
        println!(&quot;ola da thread principal&quot;);
    });
    a.push(4);
    assert_eq!(x, a.len());
}
</code></pre></pre>
<p>O que acontece é que ao criar o escopo, eu consigo fazer o empréstimo para o escopo, enquanto as threads deste escopo estiverem sendo executadas, eu consigo realizar operações com as variáveis externas sem a necessidade de utilizar o <code>move</code>, como só acessamos a variável <code>x</code> em uma das <code>threads</code> não temos problemas em modificá-la, ao fim do escopo temos acesso novamente as variáveis. Caso tentarmos modificar a variável &quot;x&quot; teremos um problema de <a href="advanced-01/../intermediary-01/03-ownership.html">ownership</a>, violando a regra de referência exclusiva das referências mutáveis.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arct"><a class="header" href="#arct">Arc&lt;T&gt;</a></h1>
<p>O <code>Smart Pointer</code> Arc&lt;T&gt; é um ponteiro com referência contada assim como o <a href="advanced-01/./02-smart-pointers-rc.html">Rc&lt;T&gt;</a> como grande diferencial de ser seguro para ser usado com <code>threads</code>, mas o que faz ele ser seguro para essa finalidade e o Rc&lt;T&gt; não? O que mais influencia neste ponto é o modo em que o seu contador é implementado, para o Rc&lt;T&gt; o contador é feito de uma maneira mais simplificada, sem nenhum tipo de preocupação com sobre escrita decorrente a leitura e escritas em momentos simultâneos, já o Arc&lt;T&gt; se preocupa com este tipo de operação e para isso utiliza <a href="https://pt.wikipedia.org/wiki/Transa%C3%A7%C3%A3o_at%C3%B4mica">operações atômicas</a>.</p>
<p>O modo de uso do Arc&lt;T&gt; e do Rc&lt;T&gt; não se distanciam muito. Temos <code>new</code>, <code>clone</code>, <code>downgrade</code>, etc. Um ponto que devemos ficar atentos é que o <code>Weak\&lt;T&gt;</code> retornado pelo <code>downgrade</code> de um <code>Arc\&lt;T&gt;</code> é de outro módulo.</p>
<pre><pre class="playground"><code class="language-rust">use std::{
    sync::{Arc, Weak},
    thread,
};

fn main() {
    let a = Arc::new(10);
    let arc_para_t1 = Arc::clone(&amp;a);
    let handle1 = thread::spawn(move || {
        println!(&quot;lendo arc da t1: {}&quot;, arc_para_t1);
        println!(
            &quot;Estou na t1 e Arc tem {} referências fortes&quot;,
            Arc::strong_count(&amp;arc_para_t1)
        );
    });
    let arc_para_t2 = Arc::clone(&amp;a);
    let handle2 = thread::spawn(move || {
        println!(&quot;lendo arc da t2: {}&quot;, arc_para_t2);
        println!(
            &quot;Estou na t2 e Arc tem {} referências fortes&quot;,
            Arc::strong_count(&amp;arc_para_t2)
        );
    });
    handle1.join().unwrap();
    handle2.join().unwrap();
    println!(
        &quot;Estou na thread main e Arc tem {} referências fortes&quot;,
        Arc::strong_count(&amp;a)
    );
}
</code></pre></pre>
<p>Ao executar o código acima, teremos saídas diferentes a cada momento da execução. Sendo possível até mesmo a impressão da seguinte maneira:</p>
<pre><code class="language-sh">lendo arc da t2: 10
lendo arc da t1: 10
Estou na t1 e Arc tem 3 referências fortes
Estou na t2 e Arc tem 3 referências fortes
Estou na thread main e Arc tem 1 referências fortes
</code></pre>
<p>Note que não tivemos problemas na diminuição de referências fortes mesmo após encerrar as duas <code>threads</code>.</p>
<h1 id="mutext"><a class="header" href="#mutext">Mutex&lt;T&gt;</a></h1>
<p>O <code>Mutex&lt;T&gt;</code> assim como a <code>RefCell\&lt;T&gt;</code> contém mutabilidade interior, é possível realizar o empréstimo mutável a partir de referências imutáveis, porém a sua peculiaridade é que para isso, o valor fica BLOQUEADO, mas como assim?
Simples quando vamos acessar o valor dentro de um <code>Mutex&lt;T&gt;</code>, ele realiza um bloqueio deste valor, então outra thread que tentar acessar este mesmo endereço de memória fica bloqueado até o momento em que a thread que realizou o bloqueio o liberar. Quando realizamos o bloqueio nos é retornado um <code>Result&lt;MutexGuard&lt;T&gt;, PoisonError&lt;...&gt;&gt;</code>.
Este <code>MutexGuard&lt;T&gt;</code> que é o responsável por liberar o bloqueio dos dados.</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::Mutex;

fn main() {
    let mutex = Mutex::new(10);
    let mutex_guard = mutex.lock().unwrap();
    println!(&quot;mutex bloqueado: {:#?}&quot;, mutex);
    drop(mutex_guard);
    println!(&quot;mutex desbloqueado: {:#?}&quot;, mutex);
}
</code></pre></pre>
<p>Repare no exemplo acima, quando imprimimos as informações de debug do <code>Mutex&lt;T&gt;</code>, quando está bloqueado, o valor do campo <code>data</code> aparece como <code>&lt;locked&gt;</code>, ou seja, o valor está bloqueado até o <code>mutex_guard</code> ser liberado. No exemplo acima utilizamos do artifício do <code>drop</code>.</p>
<p>Assim como <code>RefCell&lt;T&gt;</code> podemos realizar o bloqueio de maneira mutável.</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::Mutex;

fn main() {
    let mutex = Mutex::new(10);
    let mutex_guard = mutex.lock();
    println!(&quot;mutex bloqueado: {:#?}&quot;, mutex);
    drop(mutex_guard);
    {
        let mut valor = mutex.lock().unwrap();
        *valor = 69;
    }
    println!(&quot;mutex desbloqueado: {:#?}&quot;, mutex);
}
</code></pre></pre>
<h2 id="retomando-1"><a class="header" href="#retomando-1">Retomando</a></h2>
<p>Lembra do exemplo inicial, que não conseguimos fazer a compilação dele, nem fazer com que o comportamento fosse o desejado? Agora que conhecemos <code>Arc&lt;T&gt;</code> e <code>Mutex&lt;T&gt;</code>, conseguimos alterar aquele código para obter sucesso.</p>
<pre><pre class="playground"><code class="language-rust">use std::{
    sync::{Arc, Mutex},
    thread,
};

fn main() {
    let a = Arc::new(Mutex::new(10));
    let t2 = Arc::clone(&amp;a);
    thread::spawn(move || {
        *t2.lock().unwrap() = 42;
    })
    .join()
    .unwrap();
    thread::spawn(move || {
        println!(&quot;a = {}&quot;, a.lock().unwrap());
    })
    .join()
    .unwrap();
}
</code></pre></pre>
<p>Agora o nosso projeto compila e roda da maneira correta, conseguimos compartilhar a mesma região de memória em diversas threads diferentes, único ponto é que necessitamos de um bloqueio temporário na região de memória. 
Em aplicações reais, não teremos casos tão simples assim, como uma thread esperando outra para iniciar, varias threads podem estar rodando em simultâneo, e acessando a mesma região de memória. Felizmente, Rust é uma linguagem segura para uso em multi-thread e já nos prove muitos recursos para nos auxiliar nessa jornadas de códigos assíncronos.</p>
<h2 id="rwlockt"><a class="header" href="#rwlockt">RwLock&lt;T&gt;</a></h2>
<p>O <code>RwLock&lt;T&gt;</code> é um ponteiro com o comportamento parecido com o <code>Mutex&lt;T&gt;</code>, usamos ele quando precisamos ler um valor a partir de várias threads e apenas uma delas pode realizar operação de escrita por vez.</p>
<pre><pre class="playground"><code class="language-rust">use std::{
    sync::{Arc, RwLock},
    thread,
    time::Duration,
};

fn main() {
    let valor = Arc::new(RwLock::new(1));
    let trocas = Arc::clone(&amp;valor);
    thread::spawn(move || loop {
        thread::sleep(Duration::from_secs(5));
        println!(&quot;thread de trocas mudando o valor para valor + 1 e esperando mais 5 segundos&quot;);
        let mut write_lock = trocas.write().unwrap();
        *write_lock += 1;
        thread::sleep(Duration::from_secs(5));
    });
    let mut handles = vec![];

    for i in 1..10 {
        let v = Arc::clone(&amp;valor);
        let handle = thread::spawn(move || loop {
            thread::sleep(Duration::from_secs(1));
            let read = v.read().unwrap();
            println!(&quot;thread {} lendo o valor = {}&quot;, i + 1, read);
        });
        handles.push(handle);
    }
    for handle in handles {
        handle.join().unwrap();
    }
}
</code></pre></pre>
<p>No exemplo acima, temos uma <code>thread</code> que a cada 5 segundos realiza um bloqueio de escrita, espera mais 5 segundos e libera o bloqueio, e também temos outras 10 <code>threads</code> que a cada 1 segundo realizam a leitura do valor, repare que o único momento em que as 10 threads pausam é o momento em que a thread de escrita realiza o bloqueio e espera por 5 segundos para liberar este bloqueio. Assim que o bloqueio é liberado, as operações de leitura acontecem normalmente.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="produtores-e-consumidores"><a class="header" href="#produtores-e-consumidores">Produtores e Consumidores</a></h1>
<p>Agora que já falamos sobre <a href="advanced-01/./04-threads.html">threads</a>, conseguimos seguir com algumas estratégias para comunicação entre as threads. Em rust temos o modululo <a href="https://doc.rust-lang.org/std/sync/mpsc/">std::sync::mpsc</a> que permite a comunicação entre as threads através da memória, o que é bem interessante, porque ao invés de <a href="https://en.wikipedia.org/wiki/Concurrent_computing">competir</a> pela memória, o processo usa da memória para realizar a comunicação entre as threads.</p>
<p>Beleza, e como fazemos isso?</p>
<p>No módulo <code>mpsc</code>, conseguimos criar um canal de comunicação com a função <code>channel</code>, esta função nos devolve duas coisas, um <a href="https://doc.rust-lang.org/std/sync/mpsc/struct.Sender.html">Sender</a> e um <a href="https://doc.rust-lang.org/std/sync/mpsc/struct.Receiver.html">Receiver</a>, onde o nosso <code>sender</code> pode ser clonado, tendo mais de um produtor, sendo assim temos, múltiplos produtores e um consumidor, dai que vem o nome do módulo <code>mpsc - Multi-producer, single-consumer</code>. A função <code>channel</code> é uma função genérica, então depende de passarmos um tipo para esse parâmetro genérico para ela.</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc::{channel, Sender, Receiver};

fn main() {
    let (tx, rx): (Sender&lt;String&gt;, Receiver&lt;String&gt;) = channel::&lt;String&gt;();
}
</code></pre></pre>
<p>É comum encontrar em vários lugares os nomes <code>tx</code> e <code>rx</code> para os respectivos <code>Sender</code> e <code>Receiver</code>. Agora que criamos os canais, vamos clonar o <code>Sender</code> e criar uma thread usando ele.</p>
<pre><pre class="playground"><code class="language-rust">use std::{
    sync::mpsc::{channel, Receiver, Sender},
    thread::{sleep, spawn},
    time::Duration,
};

fn main() {
    let (tx, rx): (Sender&lt;String&gt;, Receiver&lt;String&gt;) = channel::&lt;String&gt;();

    let tx2 = tx.clone();

    spawn(move || {
        loop {
            let _ = tx2.send(&quot;hello from thread 1&quot;.to_string()); 
            sleep(Duration::from_millis(500));
        }
    });

}
</code></pre></pre>
<p>O método <code>send</code> nos devolve um <code>Result&lt;(), SendError&gt;</code>, sendo que só é possível acontecer o caso de erro caso o <code>Receiver</code> esteja fechado. Beleza, agora enviamos uma mensagem através do canal, e como consumimos ela? O <code>Receiver</code> tem um método chamado <code>recv</code> onde através dele, conseguimos ler todas as mensagens enviadas nesse canal, porém, só conseguimos ler uma mensagem por vez.</p>
<pre><pre class="playground"><code class="language-rust">use std::{
    sync::mpsc::{channel, Receiver, Sender},
    thread::{sleep, spawn},
    time::Duration,
};

fn main() {
    let (tx, rx): (Sender&lt;String&gt;, Receiver&lt;String&gt;) = channel::&lt;String&gt;();

    let tx2 = tx.clone();

    spawn(move || {
        loop {
            let _ = tx2.send(&quot;hello from thread 1&quot;.to_string()); 
            sleep(Duration::from_millis(500));
        }
    });

    let _ = spawn(move || {
        while let Ok(message) = rx.recv() {
            println!(&quot;message from thread: {message}&quot;);
        }
    }).join();
}
</code></pre></pre>
<p>Claro, podemos fazer com que várias threads produzam mensagens.</p>
<pre><pre class="playground"><code class="language-rust">use std::{
    sync::mpsc::{channel, Receiver, Sender},
    thread,
    time::Duration,
};

fn main() {
    let (tx, rx): (Sender&lt;String&gt;, Receiver&lt;String&gt;) = channel::&lt;String&gt;();

    (1..=10).map(|v| (tx.clone(), v)).for_each(|(tx, v)| {
        thread::spawn(move || loop {
            tx.send(format!(&quot;thread {v}&quot;)).unwrap();
            thread::sleep(Duration::from_secs(v));
        });
    });

    let _ = thread::spawn(move || {
        while let Ok(value) = rx.recv() {
            println!(&quot;message from {value}&quot;);
        }
    })
    .join();
}
</code></pre></pre>
<p>Temos muitas possibilidades para os <code>channels</code>, recomendo fortemente a leitura da documentação dos módulo <code>mpsc</code>, temos também algumas <code>crates</code> que possibilitam, múltiplos produtores e múltiplos consumidores, ou outras implementações além da biblioteca padrão. Quando lidamos com programação paralela isso pode ser muito útil, no <a href="https://doc.rust-lang.org/book/ch20-02-multithreaded.html">Rust Book</a> temos um bom projeto que utiliza dos canais para criar um servidor Web multi-thread.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recomendações-de-conteúdo-sobre-a-linguagem"><a class="header" href="#recomendações-de-conteúdo-sobre-a-linguagem">Recomendações de conteúdo sobre a linguagem</a></h1>
<ul>
<li><a href="https://nostarch.com/rust-rustaceans">Rust for Rustaceans</a>: livro que aborda Rust de uma maneira mais &quot;por debaixo dos panos&quot;, desde tópico mais básico até mais avançados.</li>
<li><a href="https://www.youtube.com/watch?v=rAl-9HwD858&amp;list=PLqbS7AVVErFiWDOAVrPt7aYmnuuOLYvOa">Crust of Rust</a>: série de videos abordando assuntos sobre Rust, série do autor do livro &quot;Rust for Rustceans&quot;.</li>
<li><a href="https://www.youtube.com/playlist?list=PLwhLlO5Vugx6KCwTpW_4fUeES2jdkDSW9">300 seconds of Rust</a>: série de videos curtos sobre Rust feitos pelo <a href="https://www.twitch.tv/togglebit">togglebit</a>.</li>
<li><a href="https://doc.rust-lang.org/nomicon/">Rustnomicon</a>: livro oficial da linguagem abordando assuntos sobre <code>Unsafe Rust</code>.</li>
<li><a href="https://rust-lang.github.io/async-book/">Asynchronous Programming in Rust</a>: livro oficial da linguagem sobre programação assíncrona, abordando estratégias não somente relacionadas a <a href="extras/../advanced-01/04-threads.html">threads</a></li>
<li><a href="https://bit.ly/aprendarust">Aprenda Rust - Bruno Rocha</a>: playlist em português do Brasil para aprender Rust.</li>
</ul>
<h1 id="escrito-com-rust"><a class="header" href="#escrito-com-rust">Escrito com Rust</a></h1>
<p>Softwares escritos em Rust</p>
<h2 id="ripgrep"><a class="header" href="#ripgrep">Ripgrep</a></h2>
<p>Ripgrep é uma ferramente de busca &quot;orientada a linha&quot; de modo recursivo, seu desempenho se mostra maior que outras ferramentas com o mesmo propósito.
Para saber mais: <a href="https://github.com/BurntSushi/ripgrep">repositório</a>.</p>
<h2 id="lapce"><a class="header" href="#lapce">Lapce</a></h2>
<p>Lapce é um editor de código, leve e rápido escrito em Rust, atualmente (29/08/2022) se encontra na versão 0.1.3, com plugins, visual que lembra o VSCode e também com suporte a LSP.</p>
<p>Para saber mais: <a href="https://github.com/lapce/lapce">repositório</a></p>
<h2 id="exa"><a class="header" href="#exa">Exa</a></h2>
<p>Exa pode ser utilizado no lugar do famoso comando &quot;ls&quot;.</p>
<p>Para saber mais: <a href="https://github.com/ogham/exa">repositório</a></p>
<h2 id="nushell"><a class="header" href="#nushell">Nushell</a></h2>
<p>Um novo tipo de shell feito em cima da linguagem &quot;Nu&quot;, com comandos de maneira funcional.</p>
<p>Para saber mais: <a href="https://www.nushell.sh/">site</a></p>
<h2 id="bat"><a class="header" href="#bat">Bat</a></h2>
<p>Substituo do comando &quot;cat&quot;, com &quot;Syntax highlighting&quot;, integração com git e paginação como o comando &quot;less&quot;.</p>
<p>Para saber mais: <a href="https://github.com/sharkdp/bat">repositório</a></p>
<h2 id="fd"><a class="header" href="#fd">Fd</a></h2>
<p>Fd é uma alternativa ao comando &quot;find&quot;, basicamente ele busca por ocorrências no sistema de arquivos.</p>
<p>Para saber mais: <a href="https://github.com/sharkdp/fd">repositório</a></p>
<h2 id="oha"><a class="header" href="#oha">Oha</a></h2>
<p>Gerador de carga HTTP para aplicações WEB com um TUI bem elegante.</p>
<p>Para saber mais: <a href="https://github.com/hatoo/oha">repositório</a></p>
<h2 id="mdbook"><a class="header" href="#mdbook">Mdbook</a></h2>
<p>Ferramente utilizada para construir um livro a partir de arquivos <code>markdown</code>, a mesma foi utilizada pra construir este livro.</p>
<p>Para saber mais: <a href="https://github.com/rust-lang/mdBook">repositório</a></p>
<h2 id="redoxos"><a class="header" href="#redoxos">RedoxOS</a></h2>
<p>RedoxOS é um Sistema Operacional Unix-like, com uma interface gráfica chamada Orbital, e com uma lib escrita em Rust (relibc).</p>
<p>Para saber mais: <a href="https://www.redox-os.org/">site</a></p>
<p><a href="https://github.com/rust-unofficial/awesome-rust">Neste outro</a> repositório do github você encontrara outras ferramentas escritas em Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="referências"><a class="header" href="#referências">Referências</a></h1>
<p>Informações adicionais e exemplos extraídos das seguintes fontes:</p>
<ul>
<li>https://blog.pantuza.com/artigos/heap-vs-stack</li>
<li>https://blog.rust-lang.org/2022/08/11/Rust-1.63.0.html</li>
<li>https://crates.io/crates/rand</li>
<li>https://crates.io/crates/termion</li>
<li>https://doc.rust-lang.org/book/ch15-01-box.html</li>
<li>https://doc.rust-lang.org/book/ch19-06-macros.html</li>
<li>https://doc.rust-lang.org/book/ch20-02-multithreaded.html</li>
<li>https://doc.rust-lang.org/rust-by-example/flow_control/match/guard.html</li>
<li>https://doc.rust-lang.org/rust-by-example/primitives/array.html</li>
<li>https://doc.rust-lang.org/stable/std/string/struct.String.html</li>
<li>https://doc.rust-lang.org/std/cmp/trait.PartialEq.html</li>
<li>https://doc.rust-lang.org/std/default/trait.Default.html</li>
<li>https://doc.rust-lang.org/std/sync/mpsc/</li>
<li>https://doc.rust-lang.org/std/sync/mpsc/struct.Receiver.html</li>
<li>https://doc.rust-lang.org/std/sync/mpsc/struct.Sender.html</li>
<li>https://en.wikipedia.org/wiki/Array_data_structure</li>
<li>https://en.wikipedia.org/wiki/Assertion</li>
<li>https://en.wikipedia.org/wiki/Async/await</li>
<li>https://en.wikipedia.org/wiki/Concurrent_computing</li>
<li>https://en.wikipedia.org/wiki/Data_buffer</li>
<li>https://en.wikipedia.org/wiki/Instance_(computer_science</li>
<li>https://en.wikipedia.org/wiki/JSON</li>
<li>https://en.wikipedia.org/wiki/Null_pointer</li>
<li>https://en.wikipedia.org/wiki/Pointer_(computer_programming</li>
<li>https://en.wikipedia.org/wiki/Reference_(computer_science</li>
<li>https://en.wikipedia.org/wiki/Scope_(computer_science</li>
<li>https://en.wikipedia.org/wiki/Switch_statement</li>
<li>https://en.wikipedia.org/wiki/Terminal_mode</li>
<li>https://en.wikipedia.org/wiki/Type_conversion</li>
<li>https://www.infoescola.com/matematica/formula-de-bhaskara/</li>
<li>https://nostarch.com/rust-rustaceans</li>
<li>https://pt.wikipedia.org/wiki/Transa%C3%A7%C3%A3o_at%C3%B4mica</li>
<li>https://pt.wikipedia.org/wiki/Ambiente_de_desenvolvimento_integrado</li>
<li>https://rustc-dev-guide.rust-lang.org/borrow_check.html</li>
<li>https://www.rust-lang.org/pt-BR</li>
<li>https://www.rust-lang.org/pt-BR/learn/get-started</li>
<li>https://www.techtarget.com/whatis/definition/stack-overflow</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
